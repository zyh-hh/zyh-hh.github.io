<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
    <title type="text">小青蛙de草丛</title>
    <subtitle type="html">zyhhh的个人博客。</subtitle>
    <updated>2020-09-06T13:43:37+08:00</updated>
    <id>https://example.com/</id>
    <link rel="alternate" type="text/html" href="https://example.com/" />
    <link rel="self" type="application/atom+xml" href="https://example.com/atom.xml" />
    <author>
            <name>小青蛙</name>
            <uri>https://example.com/</uri>
            
                <email>1612291475@qq.com</email>
            </author>
    <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    <generator uri="https://gohugo.io/" version="0.64.1">Hugo</generator>
        <entry>
            <title type="text">Hutool-好用的Java工具类库</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/hutool-%E5%A5%BD%E7%94%A8%E7%9A%84java%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93/" />
            <id>https://example.com/posts/hutool-%E5%A5%BD%E7%94%A8%E7%9A%84java%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93/</id>
            <updated>2020-09-06T12:05:24+08:00</updated>
            <published>2020-05-14T16:01:23+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[Hutool-好用的Java工具类库 Hutool 是一个小而全的 Java 工具类库，通过静态方法封装，降……]]></summary>
            
                <content type="html"><![CDATA[<h1 id="hutool-好用的java工具类库">Hutool-好用的Java工具类库</h1>
<blockquote>
<p>Hutool 是一个小而全的 Java 工具类库，通过静态方法封装，降低相关 API 的学习成本，提高工作效率，使 Java 拥有函数式语言般的优雅，让 Java 语言也可以“甜甜的”。
Hutool 中的工具方法来自于每个用户的精雕细琢，它涵盖了 Java 开发底层代码中的方方面面，它既是大型项目开发中解决小问题的利器，也是小型项目中的效率担当；
Hutool 是项目中“util”包友好的替代，它节省了开发人员对项目中公用类和公用工具方法的封装时间，使开发专注于业务，同时可以最大限度的避免封装不完善带来的 bug。</p>
</blockquote>
<p>上述是 Hutool 的官方介绍，它的官方文档已经介绍的很详细了，因此下面我只简单介绍几个常用的 API 操作，更多的功能我们可以详细阅读文档。</p>
<p><a href="https://www.hutool.cn/docs/#/">Hutool 官方中文文档https://www.hutool.cn/docs/#/<img src="https://site-1258928558.cos.ap-guangzhou.myqcloud.com/linkcard.png" alt="图标"></a></p>
<h1 id="hutool-中的一些常用工具类">HuTool 中的一些常用工具类</h1>
<p>我们引入这个工具类很简单，直接在 Mavan 项目中引入 dependency 即可，如果是初学者，去 <a href="https://mvnrepository.com/?__cf_chl_jschl_tk__=5f02ba3a1bede154b5c40ecd772f0fbeeb944187-1590653480-0-Ab46X745rmfQVlYfjw9OVsSrjOYPgtuxAGZkneZW0brBvL4xhNbUNw_BzTbyMTTkJ6opNPXVJn3e7blKJw8uUKTQEI8mtLehLaOqkFlkeW3WwO14IQfW4n2_HHusQ5AvEfWIpy7GXw5Bp3MGrpi-Xsczhx7Zt2G20QpQp9g6wXjsNuse8ryXmr898BTiCaj_wMJPa0TZ_noKtY_NArdqUbtwqkQA5UtHpBVcUvyy6nOBUaYKElGIzyjEgobgn-eAE-64gSw_AUB519bFV7DKN3Rr32WDRX7tdwrZGz5EFjfI7LjFEtWC0ewKat7DfNfOt6RQPGdNkQiTwFTN4SarU04">Maven Repository</a> 下载 jar 包也可以使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependency</span><span class="nt">&gt;</span>
    <span class="nt">&lt;groupId</span><span class="nt">&gt;</span>cn.hutool<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId</span><span class="nt">&gt;</span>hutool-all<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version</span><span class="nt">&gt;</span>5.3.5<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>通过 Hutool，可以减少代码搜索成本，避免网络上参差不齐的代码出现导致的bug。</p>
<h2 id="日期相关-api">日期相关 API</h2>
<p>我们知道，Java 中关于日期的 API 使用一直很繁琐，从 Date 到 Calendar，对开发者都不是那么友好，还容易出 BUG，那么 Hutool 首先就对日期下手了，提供了针对 JDK 中 Date 和 Calendar 对象的封装。</p>
<p>比如要对当前的 Date 日期进行格式化，一般使用 <code>SimpleDateFormat(yyyy-MM-dd HH:mm:ss)</code> 这种方式，但 SimpleDateFormat 这个类是线程不安全的，而 Hutool 提供了一个 <code>FastDateFormat</code> 类，提供线程安全的针对 Date 对象的格式化和日期字符串解析支持。此对象在实际使用中并不需要感知，相关操作已经封装在 <code>DateUtil</code> 和 <code>DateTime</code> 的相关方法中。</p>
<p>还有其它的日期 API 如下：</p>
<ul>
<li><code>DateUtil</code> 针对日期时间操作提供一系列静态方法</li>
<li><code>DateTim</code> 提供类似于 Joda-Time 中日期时间对象的封装，继承自 Date 类，并提供更加丰富的对象方法。</li>
<li><code>DateBetween</code> 计算两个时间间隔的类，除了通过构造新对象使用外，相关操作也已封装在 <code>DateUtil</code> 和 <code>DateTime</code> 的相关方法中。</li>
<li><code>TimeInterval</code> 一个简单的计时器类，常用于计算某段代码的执行时间，提供包括毫秒、秒、分、时、天、周等各种单位的花费时长计算，对象的静态构造已封装在 <code>DateUtil</code> 中。</li>
<li><code>DatePattern</code> 提供常用的日期格式化模式，包括 <code>String</code> 类型和 <code>FastDateFormat</code> 两种类型。</li>
</ul>
<h2 id="随机工具">随机工具</h2>
<p>随机工具应该是我们开发中用的较多的类库，Hutool 也封装了常用的 API。</p>
<ul>
<li><code>RandomUtil.randomInt</code> 获得指定范围内的随机数</li>
<li><code>RandomUtil.randomBytes</code> 随机 bytes</li>
<li><code>RandomUtil.randomEl</code> 随机获得列表中的元素</li>
<li><code>RandomUtil.randomEleSet</code> 随机获得列表中的一定量的不重复元素，返回 Set</li>
<li><code>RandomUtil.randomString</code> 获得一个随机的字符串（只包含数字和字符）</li>
<li><code>RandomUtil.randomNumbers</code> 获得一个只包含数字的字符串</li>
<li><code>RandomUtil.randomUUID</code> 随机 UUID</li>
<li><code>RandomUtil.weightRandom</code> 权重随机生成器，传入带权重的对象，然后根据权重随机获取对象</li>
</ul>
<h2 id="图片工具">图片工具</h2>
<p>针对 awt 中图片处理进行封装，这些封装包括：缩放、裁剪、转为黑白、加水印等操作。</p>
<h3 id="彩色转换成黑白">彩色转换成黑白</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//黑白转换
</span><span class="c1"></span><span class="n">ImgUtil</span><span class="o">.</span><span class="na">gray</span><span class="o">(</span><span class="n">FileUtil</span><span class="o">.</span><span class="na">file</span><span class="o">(</span><span class="s">&#34;d:/logo.png&#34;</span><span class="o">)</span><span class="o">,</span> <span class="n">FileUtil</span><span class="o">.</span><span class="na">file</span><span class="o">(</span><span class="s">&#34;d:/result.png&#34;</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="添加文字水印">添加文字水印</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ImgUtil</span><span class="o">.</span><span class="na">pressText</span><span class="o">(</span><span class="c1">//
</span><span class="c1"></span>    <span class="n">FileUtil</span><span class="o">.</span><span class="na">file</span><span class="o">(</span><span class="s">&#34;e:/pic/face.jpg&#34;</span><span class="o">)</span><span class="o">,</span> <span class="c1">//
</span><span class="c1"></span>    <span class="n">FileUtil</span><span class="o">.</span><span class="na">file</span><span class="o">(</span><span class="s">&#34;e:/pic/test2_result.png&#34;</span><span class="o">)</span><span class="o">,</span> <span class="c1">//
</span><span class="c1"></span>    <span class="s">&#34;版权所有&#34;</span><span class="o">,</span> <span class="n">Color</span><span class="o">.</span><span class="na">WHITE</span><span class="o">,</span> <span class="c1">//文字
</span><span class="c1"></span>    <span class="k">new</span> <span class="n">Font</span><span class="o">(</span><span class="s">&#34;黑体&#34;</span><span class="o">,</span> <span class="n">Font</span><span class="o">.</span><span class="na">BOLD</span><span class="o">,</span> <span class="n">100</span><span class="o">)</span><span class="o">,</span> <span class="c1">//字体
</span><span class="c1"></span>    <span class="n">0</span><span class="o">,</span> <span class="c1">//x坐标修正值。 默认在中间，偏移量相对于中间偏移
</span><span class="c1"></span>    <span class="n">0</span><span class="o">,</span> <span class="c1">//y坐标修正值。 默认在中间，偏移量相对于中间偏移
</span><span class="c1"></span>    <span class="n">0</span><span class="o">.</span><span class="na">8f</span><span class="c1">//透明度：alpha 必须是范围 [0.0, 1.0] 之内（包含边界值）的一个浮点数字
</span><span class="c1"></span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="加密解密工具">加密解密工具</h2>
<p>加密一般分为三种：</p>
<ol>
<li>对称加密（symmetric），例如：AES、DES等</li>
<li>非对称加密（asymmetric），例如：RSA、DSA等</li>
<li>摘要加密（digest），例如：MD5、SHA-1、SHA-256、HMAC等</li>
</ol>
<p>Hutool 对上述加密都提供了对应的封装方法。</p>
<h2 id="布隆过滤器">布隆过滤器</h2>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。一般用于解决 NoSQL 的缓存穿透问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 初始化
</span><span class="c1"></span><span class="n">BitMapBloomFilter</span> <span class="n">filter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BitMapBloomFilter</span><span class="o">(</span><span class="n">10</span><span class="o">)</span><span class="o">;</span>
<span class="n">filter</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;123&#34;</span><span class="o">)</span><span class="o">;</span>
<span class="n">filter</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;abc&#34;</span><span class="o">)</span><span class="o">;</span>
<span class="n">filter</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&#34;ddd&#34;</span><span class="o">)</span><span class="o">;</span>

<span class="c1">// 查找
</span><span class="c1"></span><span class="n">filter</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">&#34;abc&#34;</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="邮件工具">邮件工具</h2>
<p>在 Java中 发送邮件主要品依靠 javax.mail 包，原生 API 使用比较繁琐，Hutool 在支持邮件发送的基础上，仍然依赖于 javax.mail 包。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependency</span><span class="nt">&gt;</span>
    <span class="nt">&lt;groupId</span><span class="nt">&gt;</span>javax.mail<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId</span><span class="nt">&gt;</span>mail<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version</span><span class="nt">&gt;</span>1.4.7<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>邮件服务器的完整配置：</p>
<pre><code class="language-properties" data-lang="properties"># 邮件服务器的SMTP地址，可选，默认为smtp.&lt;发件人邮箱后缀&gt;
host = smtp.yeah.net
# 邮件服务器的SMTP端口，可选，默认25
port = 25
# 发件人（必须正确，否则发送失败）
from = hutool@yeah.net
# 用户名，默认为发件人邮箱前缀
user = hutool
# 密码（注意，某些邮箱需要为SMTP服务单独设置授权码，详情查看相关帮助）
pass = q1w2e3
</code></pre><p>发送邮件：</p>
<ul>
<li>发送普通文本邮件，最后一个参数可选是否添加多个附件：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//普通文本
</span><span class="c1"></span><span class="n">MailUtil</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="s">&#34;hutool@foxmail.com&#34;</span><span class="o">,</span> <span class="s">&#34;测试&#34;</span><span class="o">,</span> <span class="s">&#34;邮件来自Hutool测试&#34;</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>发送 HTML 格式的邮件并附带附件，最后一个参数可选是否添加多个附件：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//带HTML格式的邮件
</span><span class="c1"></span><span class="n">MailUtil</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="s">&#34;hutool@foxmail.com&#34;</span><span class="o">,</span> <span class="s">&#34;测试&#34;</span><span class="o">,</span> <span class="s">&#34;&lt;h1&gt;邮件来自Hutool测试&lt;/h1&gt;&#34;</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">FileUtil</span><span class="o">.</span><span class="na">file</span><span class="o">(</span><span class="s">&#34;d:/aaa.xml&#34;</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>群发邮件，可选 HTML 或普通文本，可选多个附件：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//群发
</span><span class="c1"></span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">tos</span> <span class="o">=</span> <span class="n">CollUtil</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span>
    <span class="s">&#34;person1@bbb.com&#34;</span><span class="o">,</span> 
    <span class="s">&#34;person2@bbb.com&#34;</span><span class="o">,</span> 
    <span class="s">&#34;person3@bbb.com&#34;</span><span class="o">,</span> 
    <span class="s">&#34;person4@bbb.com&#34;</span><span class="o">)</span><span class="o">;</span>

<span class="n">MailUtil</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">tos</span><span class="o">,</span> <span class="s">&#34;测试&#34;</span><span class="o">,</span> <span class="s">&#34;邮件来自Hutool群发测试&#34;</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="html-工具">HTML 工具</h2>
<p>比如清除富文本编辑器中的 HTML 文本的指定标签，或者只保留普通文本。</p>
<h3 id="htmlutilcleanhtmltag">HtmlUtil.cleanHtmlTag</h3>
<p>清除所有 HTM L标签，但是保留标签内的内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;pre&lt;div class=\&#34;test_div\&#34;&gt;\r\n\t\tdfdsfdsfdsf\r\n&lt;/div&gt;&lt;div class=\&#34;test_div\&#34;&gt;BBBB&lt;/div&gt;&#34;</span><span class="o">;</span>

<span class="c1">// 结果为：pre\r\n\t\tdfdsfdsfdsf\r\nBBBB
</span><span class="c1"></span><span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">HtmlUtil</span><span class="o">.</span><span class="na">cleanHtmlTag</span><span class="o">(</span><span class="n">str</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="htmlutilremovehtmltag">HtmlUtil.removeHtmlTag</h3>
<p>清除指定HTML标签和被标签包围的内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;pre&lt;img src=\&#34;xxx/dfdsfds/test.jpg\&#34;&gt;&#34;</span><span class="o">;</span>

<span class="c1">// 结果为：pre
</span><span class="c1"></span><span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">HtmlUtil</span><span class="o">.</span><span class="na">removeHtmlTag</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="s">&#34;img&#34;</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="过滤-html-文本防止-xss-攻击">过滤 HTML 文本，防止 XSS 攻击</h3>
<p>这个作用就不必多说，防止用户在输入文本中写入 HTML 标签对后台造成攻击。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">html</span> <span class="o">=</span> <span class="s">&#34;&lt;alert&gt;&lt;/alert&gt;&#34;</span><span class="o">;</span>

<span class="c1">// 结果为：&#34;&#34;
</span><span class="c1"></span><span class="n">String</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">HtmlUtil</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">html</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="json-工具">JSON 工具</h2>
<p>由于有开源并且一直在维护的 Fastjson 工具在先，所以这里就不再细说 Hutool 中的 JSON 工具，使用方法基本类似。</p>
<h1 id="写在最后">写在最后</h1>
<p>上面只是简单的介绍了 Hutool 的典型常用工具，实际上 Hutool 基本覆盖了我们日常普通开发场景涉及的大部分工具类，有兴趣的可以自行查阅文档，介绍的很全，如果使用中遇到了 BUG，也欢迎及时向作者反馈哦🙋 。</p>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/" term="常用插件" label="常用插件" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/java%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93/" term="java工具类库" label="java工具类库" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">关于异度侵入</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/%E5%85%B3%E4%BA%8E%E5%BC%82%E5%BA%A6%E4%BE%B5%E5%85%A5/" />
            <id>https://example.com/posts/%E5%85%B3%E4%BA%8E%E5%BC%82%E5%BA%A6%E4%BE%B5%E5%85%A5/</id>
            <updated>2020-04-16T17:15:51+08:00</updated>
            <published>2020-03-23T01:37:56+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200416164748.png" alt=""></p>
<p>异度侵入总算完结了，对于这部番只能说颇为遗憾吧</p>……]]></summary>
            
                <content type="html"><![CDATA[<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200416164748.png" alt=""></p>
<p>异度侵入总算完结了，对于这部番只能说颇为遗憾吧</p>
<p>这部番作为一部原创番来讲，前期做的确实很不错，剧情够硬，节奏极佳，世界观和设定都很有意思，伏笔极多，剧情创新，声优的表现和BGM都极其出彩</p>
<p>缺点也比较明显，就是世界观布置的太大了，没办法将其在13集内讲完，伏笔线索虽然多，但是很多却根本没用到，对推动剧情没有任何作用。</p>
<p>对于后三集来说，可能确实不算烂尾，但看完后还是十分失望，决战很草率，关于局长是JW这个结局，只能说很一般，首先对于局长这个人物铺垫太少，而且成为JW的动机感觉也很难说服人，还有飞鸟井这个莫名其妙的出现，莫名奇妙的“超能力”</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200416171454.png" alt=""></p>
<p>整体来说，算还不错的原创番，10分的话我还是愿意给7分的。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/%E9%9A%8F%E7%AC%94/" term="随笔" label="随笔" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/%E9%9A%8F%E7%AC%94/" term="随笔" label="随笔" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">2020开始</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/2020%E5%BC%80%E5%A7%8B/" />
            <id>https://example.com/posts/2020%E5%BC%80%E5%A7%8B/</id>
            <updated>2020-04-13T00:36:02+08:00</updated>
            <published>2020-01-01T06:07:00+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200413001816.png" alt=""></p>
<blockquote>
<p>2019就这样过去了，2020开始了</p>
</blockquote>……]]></summary>
            
                <content type="html"><![CDATA[<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200413001816.png" alt=""></p>
<blockquote>
<p>2019就这样过去了，2020开始了</p>
</blockquote>
<p>2019年是博客开始的第一年，时间过得真的是太快了，在这一年里，有些目标完成了，有些却还没开始，生活总是差强人意，感觉我也做得不够好，不想太过感伤，希望新的一年能给我带来好运吧！</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/tokio1.jpg" alt=""></p>
<p>最后，祝大家新年快乐！</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/%E9%9A%8F%E7%AC%94/" term="随笔" label="随笔" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/%E9%9A%8F%E7%AC%94/" term="随笔" label="随笔" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">给博客添加评论Valine</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9Fvaline/" />
            <id>https://example.com/posts/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9Fvaline/</id>
            <updated>2020-04-17T00:08:26+08:00</updated>
            <published>2019-12-02T01:37:56+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<blockquote>
<p>Valine - 一款快速、简洁且高效的无后端评论系统。</p>
<p>Valine 诞生于2017年8月7日，是一款基于Leancloud的快速、简洁且高效的无后端评论系统。</p>
</blockquote>
<p>理论上支持但不限于静态博客，目前已有Hexo、Hugo、Typecho等博客程序在使用Valine。</p>
<p>特性：</p>
<ul>
<li>快速</li>
<li>安全</li>
<li>Emoji 😉</li>
<li>无后端实现</li>
<li>MarkDown 全语法支持</li>
<li>轻量易用(~15kb gzipped)</li>
</ul>……]]></summary>
            
                <content type="html"><![CDATA[<blockquote>
<p>Valine - 一款快速、简洁且高效的无后端评论系统。</p>
<p>Valine 诞生于2017年8月7日，是一款基于Leancloud的快速、简洁且高效的无后端评论系统。</p>
</blockquote>
<p>理论上支持但不限于静态博客，目前已有Hexo、Hugo、Typecho等博客程序在使用Valine。</p>
<p>特性：</p>
<ul>
<li>快速</li>
<li>安全</li>
<li>Emoji 😉</li>
<li>无后端实现</li>
<li>MarkDown 全语法支持</li>
<li>轻量易用(~15kb gzipped)</li>
</ul>
<p><strong>Tips:</strong></p>
<ul>
<li>整个过程，是以Meme主题为例的，其它主题操作大同小异。</li>
<li>配置之前应该先阅读<a href="https://valine.js.org/quickstart.html">Valine快速开始</a></li>
</ul>
<h2 id="leancloud相关配置">Leancloud相关配置</h2>
<p>评论系统依赖于leancloud，所以需要先在leancloud中进行相关的准备工作。</p>
<ul>
<li>
<p><a href="https://leancloud.cn/dashboard/login.html#/signin">登录</a> 或 <a href="https://leancloud.cn/dashboard/login.html#/signup">注册</a> LeanCloud</p>
</li>
<li>
<p>登录成功后，进入后台点击左上角的创建应用：</p>
<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20180708153104380829479.png" alt="img"></p>
</li>
<li>
<p>创建好应用，进入应用，左边栏找到设置，然后点击应用Key，此时记录出现的App ID和App Key，后面配置文件中会用到：</p>
<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20180708153104457148134.png" alt="img"></p>
</li>
<li>
<p>因为评论和文章阅读数统计依赖于存储，所以还需要建立两个新的存储</p>
<pre><code>Class
</code></pre><p>左边栏找到并点击存储，点击创建Class:</p>
<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20180708153104475972323.png" alt="img"></p>
</li>
<li>
<p>创建两个存储Class，分别命名为: <code>Counter</code> 和 <code>Comment</code>;</p>
</li>
<li>
<p>还需要为应用添加安全域名，左边栏点击设置，找到安全中心，点击后会看到安全域名设置框，输入博客使用的域名，点击保存即可：</p>
<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20180708153104592457270.png" alt="img"></p>
</li>
</ul>
<h2 id="configtoml添加参数">config.toml添加参数</h2>
<p>为了使配置更灵活，将 <strong>Valine</strong> 中大部分初始化参数项均设置为配置文件中的参数项，在 <strong>config.toml</strong> 的适当位置，比如我的文件中 <strong>[params.gitment]</strong> 的下面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-toml" data-lang="toml">  <span class="p">[</span><span class="nx">params</span><span class="p">.</span><span class="nx">gitment</span><span class="p">]</span>          <span class="c"># Gitment is a comment system based on GitHub issues. see https://github.com/imsun/gitment</span>
    <span class="nx">owner</span> <span class="p">=</span> <span class="s2">&#34;&#34;</span>              <span class="c"># Your GitHub ID</span>
    <span class="nx">repo</span> <span class="p">=</span> <span class="s2">&#34;&#34;</span>               <span class="c"># The repo to store comments</span>
    <span class="nx">clientId</span> <span class="p">=</span> <span class="s2">&#34;&#34;</span>           <span class="c"># Your client ID</span>
    <span class="nx">clientSecret</span> <span class="p">=</span> <span class="s2">&#34;&#34;</span>       <span class="c"># Your client secret</span>

  <span class="c"># 这里添加Valine的相关参数</span>
</code></pre></td></tr></table>
</div>
</div><p>添加 <strong>Valine</strong> 参数项：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-toml" data-lang="toml">  <span class="c"># Valine.</span>
  <span class="c"># You can get your appid and appkey from https://leancloud.cn</span>
  <span class="c"># more info please open https://valine.js.org</span>
  <span class="p">[</span><span class="nx">params</span><span class="p">.</span><span class="nx">valine</span><span class="p">]</span>
    <span class="nx">enable</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="nx">appId</span> <span class="p">=</span> <span class="s1">&#39;你的appId&#39;</span>
    <span class="nx">appKey</span> <span class="p">=</span> <span class="s1">&#39;你的appKey&#39;</span>
    <span class="nx">notify</span> <span class="p">=</span> <span class="kc">false</span>  <span class="c"># mail notifier , https://github.com/xCss/Valine/wiki</span>
    <span class="nx">verify</span> <span class="p">=</span> <span class="kc">false</span> <span class="c"># Verification code</span>
    <span class="nx">avatar</span> <span class="p">=</span> <span class="s1">&#39;mm&#39;</span> 
    <span class="nx">placeholder</span> <span class="p">=</span> <span class="s1">&#39;说点什么吧...&#39;</span>
    <span class="nx">visitor</span> <span class="p">=</span> <span class="kc">true</span>
</code></pre></td></tr></table>
</div>
</div><p>上面几项内容的含义，这里简单一说，具体还是要看 <a href="https://valine.js.org/configuration.html">Valine官网中配置相关的内容</a>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>enable</td>
<td>这是用于主题中配置的，不是官方Valine的参数，<strong>true</strong>时控制开启此评论系统</td>
</tr>
<tr>
<td>appId</td>
<td>这是在 <a href="https://leancloud.cn/">leancloud</a> 后台应用中获取的，也就是上面提到的 <strong>App ID</strong></td>
</tr>
<tr>
<td>appKey</td>
<td>这是在 <a href="https://leancloud.cn/">leancloud</a> 后台应用中获取的，也就是上面提到的 <strong>App Key</strong></td>
</tr>
<tr>
<td>notify</td>
<td>用于控制是否开启邮件通知功能，具体参考<a href="https://github.com/xCss/Valine/wiki/Valine-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92%E8%AE%BE%E7%BD%AE">邮件提醒配置</a></td>
</tr>
<tr>
<td>verify</td>
<td>用于控制是否开启评论验证码功能</td>
</tr>
<tr>
<td>avatar</td>
<td>用于配置评论项中用户头像样式，有多种选择：mm, identicon, monsterid, wavatar, retro, hide。详细参考：<a href="https://valine.js.org/avatar.html">头像配置</a></td>
</tr>
<tr>
<td>placehoder</td>
<td>评论框的提示符</td>
</tr>
<tr>
<td>visitor</td>
<td>控制是否开启文章阅读数的统计功能i, 详情阅读<a href="https://valine.js.org/visitor.html">文章阅读数统计</a></td>
</tr>
</tbody>
</table>
<h2 id="修改主题文件">修改主题文件</h2>
<p>主要是修改主题中评论相关的布局文件 <code>themes/even/layouts/partials/comments.html</code>，按照 <a href="https://valine.js.org/quickstart.html">Valine快速开始</a> 添加 <strong>Valine</strong> 相关代码，找到以下位置，大概55～81行的位置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">  <span class="c">&lt;!--</span><span class="c"> gitment </span><span class="c">--&gt;</span>
  {{- if .Site.Params.gitment.enable -}}
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;comments-gitment&#34;</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="c">&lt;!--</span><span class="c">这里省略了部分代码</span><span class="c">--&gt;</span>
  <span class="p">&lt;</span><span class="nt">noscript</span><span class="p"></span><span class="p">&gt;</span>Please enable JavaScript to view the <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://github.com/imsun/gitment&#34;</span><span class="p"></span><span class="p">&gt;</span>comments powered by gitment.<span class="p">&lt;</span><span class="p">/</span><span class="nt">a</span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">noscript</span><span class="p">&gt;</span>
  {{- end }}

  <span class="c">&lt;!--</span><span class="c">这个位置添加Valine相关代码</span><span class="c">--&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>添加的 <strong>Valine</strong> 评论的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html">  <span class="c">&lt;!--</span><span class="c"> valine </span><span class="c">--&gt;</span>
  {{- if .Site.Params.valine.enable -}}
  <span class="c">&lt;!--</span><span class="c"> id 将作为查询条件 </span><span class="c">--&gt;</span>
  <span class="p">&lt;</span><span class="nt">span</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;{{ .URL | relURL }}&#34;</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;leancloud_visitors&#34;</span> <span class="na">data-flag-title</span><span class="o">=</span><span class="s">&#34;{{ .Title }}&#34;</span><span class="p"></span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">span</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-meta-item-text&#34;</span><span class="p"></span><span class="p">&gt;</span>文章阅读量 <span class="p">&lt;</span><span class="p">/</span><span class="nt">span</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">span</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;leancloud-visitors-count&#34;</span><span class="p"></span><span class="p">&gt;</span>1000000<span class="p">&lt;</span><span class="p">/</span><span class="nt">span</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">p</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="p">/</span><span class="nt">span</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;vcomments&#34;</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;//cdn1.lncld.net/static/js/3.0.4/av-min.js&#34;</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">script</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#39;//unpkg.com/valine/dist/Valine.min.js&#39;</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">script</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/javascript&#34;</span><span class="p"></span><span class="p">&gt;</span>
    <span class="k">new</span> <span class="nx">Valine</span><span class="p">(</span><span class="p">{</span>
        <span class="nx">el</span><span class="o">:</span> <span class="s1">&#39;#vcomments&#39;</span> <span class="p">,</span>
        <span class="nx">appId</span><span class="o">:</span> <span class="s1">&#39;{{ .Site.Params.valine.appId }}&#39;</span><span class="p">,</span>
        <span class="nx">appKey</span><span class="o">:</span> <span class="s1">&#39;{{ .Site.Params.valine.appKey }}&#39;</span><span class="p">,</span>
        <span class="nx">notify</span><span class="o">:</span> <span class="p">{</span><span class="p">{</span> <span class="p">.</span><span class="nx">Site</span><span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nx">valine</span><span class="p">.</span><span class="nx">notify</span> <span class="p">}</span><span class="p">}</span><span class="p">,</span> 
        <span class="nx">verify</span><span class="o">:</span> <span class="p">{</span><span class="p">{</span> <span class="p">.</span><span class="nx">Site</span><span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nx">valine</span><span class="p">.</span><span class="nx">verify</span> <span class="p">}</span><span class="p">}</span><span class="p">,</span> 
        <span class="nx">avatar</span><span class="o">:</span><span class="s1">&#39;{{ .Site.Params.valine.avatar }}&#39;</span><span class="p">,</span> 
        <span class="nx">placeholder</span><span class="o">:</span> <span class="s1">&#39;{{ .Site.Params.valine.placeholder }}&#39;</span><span class="p">,</span>
        <span class="nx">visitor</span><span class="o">:</span> <span class="p">{</span><span class="p">{</span> <span class="p">.</span><span class="nx">Site</span><span class="p">.</span><span class="nx">Params</span><span class="p">.</span><span class="nx">valine</span><span class="p">.</span><span class="nx">visitor</span> <span class="p">}</span><span class="p">}</span>
    <span class="p">}</span><span class="p">)</span><span class="p">;</span>
  <span class="p">&lt;</span><span class="p">/</span><span class="nt">script</span><span class="p">&gt;</span>
  {{- end }}
</code></pre></td></tr></table>
</div>
</div><p>可以看到上述代码中引用了配置文件中的相关参数，这样以后修改配置就不用修改代码了，只需要改配置文件 <code>config.toml</code>，另外注意到的是，我也添加了文章阅读数统计的显示内容。将配置文件中 <strong>valine</strong> 配置的 <code>eanble</code> 设置为 <code>true</code> ，本地测试一下，正常的话，打开一篇文章会看到：</p>
<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20180708153104555886981.png" alt="img"></p>
<p>此时，生成静态博客文件，部署到自己的托管平台，正常的话打开博客中的一篇文章，就可以看到正常的文章计数和评论框了，此时随便评论一条，验证一下，评论如果成功，可以去leancloud后台看一下 <code>Comment</code> 和 <code>Counter</code>存储中新加了相应网址的条目。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/%E5%8D%9A%E5%AE%A2/" term="博客" label="博客" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/%E5%8D%9A%E5%AE%A2/" term="博客" label="博客" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">github在线阅读神器sourcegraph测评</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/sourcegraph%E4%BD%BF%E7%94%A8/" />
            <id>https://example.com/posts/sourcegraph%E4%BD%BF%E7%94%A8/</id>
            <updated>2020-09-06T12:01:29+08:00</updated>
            <published>2019-04-14T16:01:23+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<p>GitHub 在的使用体验并不算太好，GitHub 访问起来比较卡，在网络比较卡的情况下，如果我们想在线查看 GitHub 上项目的源码，是非常的不方便，我们需要不断的进入到某个目录中，然后再退出来，再进入到其他目录中，这样每一次都要加载页面，查看起来非常不便。</p>
<p>通过朋友了解了sourcegraph这款在线阅读github的插件神器</p>……]]></summary>
            
                <content type="html"><![CDATA[<p>GitHub 在的使用体验并不算太好，GitHub 访问起来比较卡，在网络比较卡的情况下，如果我们想在线查看 GitHub 上项目的源码，是非常的不方便，我们需要不断的进入到某个目录中，然后再退出来，再进入到其他目录中，这样每一次都要加载页面，查看起来非常不便。</p>
<p>通过朋友了解了sourcegraph这款在线阅读github的插件神器</p>
<p><strong>这里我就来和大家演示下正常安装，在 Chrome 的 Store 中搜索 SourceGraph ，如下</strong></p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200424182718.png" alt=""></p>
<p>搜到之后点击右边的 <strong>添加至 Chrome</strong> 按钮即可，我这边因为已经装过了，所以按钮是评分，安装完成之后，浏览器上会多出一个 SourceGraph 图标，如下：</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200424215135.png" alt=""></p>
<p>这样 SourceGraph 就安装好了。</p>
<h3 id="使用">使用</h3>
<p>此时我们在 GitHub 上打开任意一个项目，以mybatis为例，如下：</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200424182650.png" alt=""></p>
<p><strong>可以看到，在项目的 Watch 旁边多了一个按钮，这个按钮就是 SourceGraph</strong></p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200424182743.png" alt=""></p>
<p><strong>我们点击一下，就可以进入到 SourceGraph 页面：</strong></p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200424213835.png" alt=""></p>
<p>目录结构清晰</p>
<p><strong>点进一个类看看，可以发现页面做了样式渲染，类似idea</strong></p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200424213916.png" alt=""></p>
<p><strong>它也可以通过点击查看变量被定义或者被引用的位置(这个功能要登录 SourceGraph 后才可以使用)：</strong></p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200424214642.png" alt=""></p>
<p>体验确实挺不错的，有了这些功能，我们再在 GitHub 上浏览项目就方便多了。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/" term="常用插件" label="常用插件" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/github/" term="github" label="github" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">单例模式</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" />
            <id>https://example.com/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
            <updated>2020-04-15T10:27:31+08:00</updated>
            <published>2019-04-02T01:37:56+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<h2 id="一单例模式">一、单例模式</h2>
<p>在标准的23种设计模式种，单例设计模式在应用中是非常常见的，而我们在学习单例模式中，一定要考虑到和多线程结合起来时可能存在的各种问题以及其解决办法，这样我们才能写出一个在多线程环境下安全、正确的单例模式。</p>……]]></summary>
            
                <content type="html"><![CDATA[<h2 id="一单例模式">一、单例模式</h2>
<p>在标准的23种设计模式种，单例设计模式在应用中是非常常见的，而我们在学习单例模式中，一定要考虑到和多线程结合起来时可能存在的各种问题以及其解决办法，这样我们才能写出一个在多线程环境下安全、正确的单例模式。</p>
<p>单例模式常见的有八种写法(更多时候分为六种，此处更加细分了)：</p>
<ul>
<li>饿汉式（静态常量）</li>
<li>饿汉式（静态代码块）</li>
<li>懒汉式（线程不安全）</li>
<li>懒汉式（线程安全，同步方法）</li>
<li>懒汉式（线程安全，同步代码块）</li>
<li>双重检查锁</li>
<li>静态内部类</li>
<li>枚举</li>
</ul>
<hr>
<h2 id="二单例模式的基本实现思路">二、单例模式的基本实现思路：</h2>
<p>单例模式要求类能够有返回对象的一个引用（并且永远是同一个）和一个获得该实例的方法（必须是静态方法，往往使用<code>getInstance()</code>这个方法）</p>
<p>单例模式的实现主要通过以下步骤：</p>
<p>（1）将该类的构造方法定义为<strong>私有方法</strong>，这样其它的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</p>
<p>（2）在该类种提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋值给该类保持的引用。</p>
<p>注意事项：单例模式在多线程的环境下必须小心使用，如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被创建了出来，从而违反了单例模式种实例唯一的原则，解决的办法显而易见是加锁。</p>
<h2 id="三单例模式的八种写法">三、单例模式的八种写法</h2>
<h3 id="1饿汉式静态常量">1、饿汉式（静态常量）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nf">singleton</span><span class="o">(</span><span class="o">)</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    
    <span class="c1">//注意构造方法必须私有
</span><span class="c1"></span>    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">(</span><span class="o">)</span><span class="o">{</span><span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">(</span><span class="o">)</span><span class="o">{</span>
        <span class="k">return</span> <span class="n">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>优点：写法简单，就是在类加载的时候完成实例化，避免了线程同步问题。</p>
<p>缺点：没有达到懒加载的效果，如果从始至终都未使用过这个实例，会造成内存的浪费。</p>
<h3 id="2饿汉式静态代码块">2、饿汉式（静态代码块）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">instance</span><span class="o">;</span>
    
    <span class="kd">static</span><span class="o">{</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">(</span><span class="o">)</span><span class="o">{</span><span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">(</span><span class="o">)</span><span class="o">{</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这种方式跟第一种方式类似，都是在类加载的时候完成的，只不过将实例化的过程放在了静态代码块种，优缺点跟上面一样。</p>
<h3 id="3懒汉式线程不安全">3、懒汉式（线程不安全）</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">instance</span><span class="o">;</span>
    
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">(</span><span class="o">)</span><span class="o">{</span><span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">getInstance</span><span class="o">(</span><span class="o">)</span><span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">instance</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span><span class="o">{</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这种写法在单线程环境下可以使用，但是多线程环境下显然会产生多个实例。</p>
<h3 id="4懒汉式线程安全同步方法">4、懒汉式（线程安全，同步方法）</h3>
<pre><code>public class Singleton{
    private static Singleton instance;
    
    private Singleton(){}
    
    public static synchronized Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
</code></pre><p>这种方法是对上面的线程不安全的懒汉式的改进。</p>
<p>由于每次去获取实例的时候都会进入<code>synchronized</code>代码块而不管实例是否为null，而其实这个方法只需要执行一次实例化代码就可以，因此这样的开销非常大，所以不推荐使用。</p>
<h3 id="5懒汉式线程安全同步代码块">5、懒汉式（线程安全，同步代码块）</h3>
<pre><code>public class Singleton{
    private static Singleton instance;
    
    private Singleton(){}
    
    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                instance = new Singleton();
            }
        }
        return instance;
    }
}
</code></pre><p>并不能起到线程同步的作用，跟第三种方式遇到的情形一致。假如两个线程同时进入了<code>if(instance == null)</code>代码块，那么还是会产生多个实例，因此同样不推荐使用。</p>
<h3 id="6双重检查锁">6、双重检查锁</h3>
<pre><code>public class Singleton{
    private static volatile Singleton singleton;
    
    private Singleton(){}
    
    public static Singleton getInstance(){
        if(singleton == null){
            synchronized(Singleton.class){
                if(singleton == null){
                    singleton = new Singleton():
                }
            }
        }
        return singleton;
    }
}
</code></pre><p>双重检查锁对于多线程开发者来说并不陌生，我们进行了两次<code>if(singleton == null)</code>判断，并通过将实例singleton设置为<code>volatile</code>变量，这样可以实现变量的可见性并且禁止编译器指令重排序造成的其它问题。</p>
<p>优点：线程安全，延迟加载，效率较高。</p>
<h3 id="7静态内部类">7、静态内部类</h3>
<pre><code>public class Singleton{
    private Singleton(){}
    
    private static class SingletonInstance{
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance(){
        return SingletonInstance.INSTANCE;
    }
}
</code></pre><p>这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading（懒加载）的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。</p>
<p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，<strong>JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</strong></p>
<p>优点：避免了线程不安全，延迟加载，效率高。</p>
<h3 id="8枚举">8、枚举</h3>
<pre><code>public enum Singleton{
    INSTANCE;
    public void whateverMethod(){
        
    }
}
</code></pre><p>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，使用枚举实现单例模式很少出现。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/java/" term="java" label="java" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">为什么String是不可变类型</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/%E4%B8%BA%E4%BB%80%E4%B9%88string%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/" />
            <id>https://example.com/posts/%E4%B8%BA%E4%BB%80%E4%B9%88string%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/</id>
            <updated>2020-09-06T12:01:10+08:00</updated>
            <published>2019-03-23T01:37:56+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<h1 id="为什么string是不可变类型">为什么String是不可变类型</h1>
<p>String作为最常用的字符串类型，一直以来都没有了解它的实际构成，今天来简单分析一下它为什么是不可变类型！</p>……]]></summary>
            
                <content type="html"><![CDATA[<h1 id="为什么string是不可变类型">为什么String是不可变类型</h1>
<p>String作为最常用的字符串类型，一直以来都没有了解它的实际构成，今天来简单分析一下它为什么是不可变类型！</p>
<p>我们通过查看String的源码可以发现，String的本质就是被final修饰的char[],数组中每个字符拼接起来就成为了字符串;</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200810100237.png" alt=""></p>
<p>很多人都说因为String是被final修饰的，所以是不可变类型，其实这是错误的观点，String确实是不可变类型，但是不仅仅只是被fianl修饰。</p>
<p>final关键字修饰类时该类不可被继承，当一个属性被修饰时，当该属性为基本数据类型，它的值不可以改变，如果是数组或者引用类型时，那么仅仅是数组或者引用类型的地址不可以改变，但是内存地址上的值是可以改变的。</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200810104850.png" alt=""></p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200810104901.png" alt=""></p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200810111050.png" alt=""></p>
<p>String为不可变类型的另一个原因是开发者在设计String时对这个value进行了权限控制(private)，以及每次操作生产新对象，也就是每次对String对象操作时，都不是在原有value这个数组上进行改动的，而是生成一个新的value数组，并对其进行操作，如下图所示。</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200810113107.png" alt=""></p>
<p>String为什么被设计成不可变类型，最主要就是安全，String是在java中除了基本数据类型外最最常用的类型，几乎每个类都会用到，之所以把String设计成不可变类型最主要的优点就是安全，主要体现在 以下：</p>
<ul>
<li>无法被继承，私有方法不能被重写，(例如func(String str),func方法中只能传入String类型，而不能传入它的子类，放弃了多态的特性，方便语义上的统一)</li>
<li>每次操作生成新的对象</li>
<li>线程安全，因为String是不可变的，多个线程无法修改同一个String对象的值，能保持线程安全</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/java%E5%B8%B8%E7%94%A8%E7%B1%BB/" term="java常用类" label="java常用类" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/java/" term="java" label="java" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">ConcurrentHashMap源码分析</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/concurrenthashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" />
            <id>https://example.com/posts/concurrenthashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
            <updated>2020-04-24T22:43:48+08:00</updated>
            <published>2019-03-20T16:01:23+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<h3 id="什么是concurrenthashmap">什么是ConcurrentHashMap</h3>
<blockquote>
<p>ConcurrentHashMap 是线程安全且高效的 HashMap。使用 ConcurrentHashMap 的主要原因是 HashMap 是非线程安全的（HashMap 线程不安全的原因可以参考<a href="https://zyhhh.top/posts/ConcurrentHashMap.html">这里</a>），如果要在多线程环境下使用 Map 结构，可以有以下方式：</p>
<ol>
<li>使用 Collections.synchronizedMap(HashMap&lt;K,V&gt; ()) 方法把 HashMap 变成一个线程安全的 Map</li>
<li>使用 HashTable</li>
<li>使用 ConcurrentHashMap</li>
</ol>
</blockquote>……]]></summary>
            
                <content type="html"><![CDATA[<h3 id="什么是concurrenthashmap">什么是ConcurrentHashMap</h3>
<blockquote>
<p>ConcurrentHashMap 是线程安全且高效的 HashMap。使用 ConcurrentHashMap 的主要原因是 HashMap 是非线程安全的（HashMap 线程不安全的原因可以参考<a href="https://zyhhh.top/posts/ConcurrentHashMap.html">这里</a>），如果要在多线程环境下使用 Map 结构，可以有以下方式：</p>
<ol>
<li>使用 Collections.synchronizedMap(HashMap&lt;K,V&gt; ()) 方法把 HashMap 变成一个线程安全的 Map</li>
<li>使用 HashTable</li>
<li>使用 ConcurrentHashMap</li>
</ol>
</blockquote>
<p>为什么不用 HashTable 呢，这是因为 HashTable 的效率非常低，其内部方法都是使用 Synchronized 来保证线程安全，并且若线程竞争激烈时，HashTable 的效率会变得更加低，因为当一个线程访问 HashTable 的同步方法，其它线程也访问 HashTable 的同步方法，那么会进入阻塞或者轮询状态。比如线程 1 使用 put 方法进行元素添加，线程 2 不但不能使用 put 方法添加元素，还不能使用 get 方法查询元素。所以多线程环境下往往不会使用 HashTable。</p>
<p>为了解决上述问题，Java 官方提供了 ConcurrentHashMap 类来实现并发访问性能较高的 HashMap。其优点如下：</p>
<ul>
<li>线程安全</li>
<li>相比于 HashTable 和 Collections.synchronizedMap() 效率高</li>
</ul>
<h3 id="concurrenthashmap的结构">ConcurrentHashMap的结构</h3>
<p>ConcurrentHashMap 在 JDK 1.7 和 JDK 1.8 的结构是不相同的，这里我们先解析 JDK 1.7 下的 ConcurrentHashMap，在这个基础上再分析 JDK 1.8 下 ConcurrentHashMap 的实现并比较与 1.7 做出了什么优化。</p>
<h4 id="jdk17下的concurrenthashmap">JDK1.7下的ConcurrentHashMap</h4>
<p>在 JDK 1.7 中，ConcurrentHashMap 的结构是分段锁（segment） + HashEntry 数组。ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<p><a href="https://blogimage-1258928558.cos.ap-guangzhou.myqcloud.com/ConcurrentHashMap/jdk1.7-concurrenthashmap.png"><img src="https://blogimage-1258928558.cos.ap-guangzhou.myqcloud.com/ConcurrentHashMap/jdk1.7-concurrenthashmap.png" alt="img"></a></p>
<p>其中 segment 是一种可重入锁（ReentrantLock），在 ConcurrentHashMap 中扮演锁的角，HashEntry 则用于寸储键值对数据。一个 ConcurrentHashMap 中包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表的结构，一个 Segment 中包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。每个 Segment 守护着一个 HashEntry 数组里面的元素，对 HashEntry 数组中元素进行修改时，必须先获取对应的 Segment 锁。</p>
<h4 id="jdk18下的concurrenthashmap">JDK1.8下的ConcurrentHashMap</h4>
<p>JDK 1.8 中 ，ConcurrentHashMap 的结构是数组 + 链表 + 红黑树，不再是分段锁（segment）机制，而是采用了 CAS + Synchronized 细化了锁粒度，从而提升了并发性能，并且在数组链表长度超过 8 时，会自动将链表转化为红黑树，这样解决了散列不均匀产生链表过长从而使得搜索时间复杂度过大的问题。</p>
<p><a href="https://blogimage-1258928558.cos.ap-guangzhou.myqcloud.com/ConcurrentHashMap/jdk1.8-concurrenthashmap.png"><img src="https://blogimage-1258928558.cos.ap-guangzhou.myqcloud.com/ConcurrentHashMap/jdk1.8-concurrenthashmap.png" alt="img"></a></p>
<p>Synchronized 只锁定当前链表或者红黑树的首节点，这样只要 hash 不冲突，就不会产生并发，从而提升了一定的并发性能。</p>
<h3 id="concurrenthashmap的源码分析">ConcurrentHashMap的源码分析</h3>
<p>为了更全面的理解 ConcurrentHashMap 的源码和发展历史，这里也分为 JDK 1.7 和 JDK 1.8 中的 ConcurrentHashMap 源码分析。</p>
<h4 id="jdk-17-源码">JDK 1.7 源码</h4>
<p>由上面小节我们初步了解了 ConcurrentHashMap 在 1.7 中的数据结构，其中我们需要关注的点：</p>
<ul>
<li>ConcurrentHashMap 如何定位 Segment, 如何定位 HashEntry</li>
<li>修改的加锁逻辑，如何进行扩容</li>
<li>读数据时，如何做到不加锁但保证线程安全的？</li>
</ul>
<p>ConcurrentHashMap 的默认常量字段有：</p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">含义</th>
<th align="center">初始值</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">DEFAULT_INITIAL_CAPACITY</td>
<td align="center">初始容量</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">DEFAULT_LOAD_FACTOR</td>
<td align="center">初始负载因子</td>
<td align="center">0.75</td>
</tr>
<tr>
<td align="center">DEFAULT_CONCURRENCY_LEVEL</td>
<td align="center">并发度</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">MAX_SEGMENTS</td>
<td align="center">segment最大容量</td>
<td align="center">2^16</td>
</tr>
<tr>
<td align="center">RETRIES_BEFORE_LOCK</td>
<td align="center">重试次数</td>
<td align="center">2</td>
</tr>
</tbody>
</table>
<p>ConcurrentHashMap 的初始化方法也是通过 initialCapacity、loadFactor 和 ConcurrencyLevel 等几个参数初始化 segement 数组、段偏移量 segmentShift、段掩码 segmentMask 和每个 segment 中的 HashEntry 数组来实现的。</p>
<p>复制</p>
<pre><code>public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {
    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
        throw new IllegalArgumentException();
	
    if (concurrencyLevel &gt; MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;

    // Find power-of-two sizes best matching arguments
    int sshift = 0;  
    int ssize = 1;
    while (ssize &lt; concurrencyLevel) {
        ++sshift;
        ssize &lt;&lt;= 1;
    }
    segmentShift = 32 - sshift;
    segmentMask = ssize - 1;
    this.segments = Segment.newArray(ssize);

    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize &lt; initialCapacity)
        ++c;
    int cap = 1;
    while (cap &lt; c)
        cap &lt;&lt;= 1;

    for (int i = 0; i &lt; this.segments.length; ++i)
        this.segments[i] = new Segment&lt;K,V&gt;(cap, loadFactor);
}
</code></pre><h5 id="初始化segment数组">初始化segment数组</h5>
<p>初始化 segment 数组源码如下：</p>
<p>复制</p>
<pre><code>//并发度最大只有segmengs数组大小
if (concurrencyLevel &gt; MAX_SEGMENTS)
    concurrencyLevel = MAX_SEGMENTS;

// Find power-of-two sizes best matching arguments
// 为了保证segemnts数组长度为2的N次方
int sshift = 0;  
int ssize = 1;  //segment数组的长度
while (ssize &lt; concurrencyLevel) {
    ++sshift;
    ssize &lt;&lt;= 1;
}
segmentShift = 32 - sshift;
segmentMask = ssize - 1;
this.segments = Segment.newArray(ssize);
</code></pre><p>由上可知，segments 数组的长度 ssize 是通过 concurrencyLevel 计算得出的。为了能通过按为与的散列算法来定位 segments 数组的索引，必须保证 segments 数组的长度为 2 的 N 次方（power-of-two size），所以必须计算出一个大于或等于 concurrencyLevel 的最小的 2 的 N 次方来作为 segments 数组的长度。</p>
<p>比如假如concurrencyLevel 等于 14 、15 或者 16，ssize 都会等于 16，即容器里面锁的个数也是 16。</p>
<h5 id="初始化segmentshift和segmentmask">初始化segmentShift和segmentMask</h5>
<p>这两个全局变量需要在定位 segment 时的散列算法中使用，sshift 等于 ssize 从 1 向左移位的次数，在默认情况下 concurrencyLevel 等于 16，1 需要往左移位移动 4 次，所以 sshift 等于 4。segmentShift 用于定位参与散列函数运算的位数， <code>segmentShift = 32 - sshift</code>，所以等于 28，这里之所以用 32 是因为 ConcurrentHashMap 里的 hash() 方法输出的最大数是 32 位的，后面的测试中我们可以看到这点。 segmentMask 是散列运算的掩码，等于 ssize - 1，即最大值是 16， segmentMask 的最大值为 65535。</p>
<h5 id="初始化每个segment">初始化每个segment</h5>
<p>源码如下：</p>
<p>复制</p>
<pre><code>if (initialCapacity &gt; MAXIMUM_CAPACITY)
    initialCapacity = MAXIMUM_CAPACITY;
int c = initialCapacity / ssize;
if (c * ssize &lt; initialCapacity)
    ++c;
int cap = 1;  // c就是segment中HashEntry数组的长度
while (cap &lt; c)
    cap &lt;&lt;= 1;

for (int i = 0; i &lt; this.segments.length; ++i)
    this.segments[i] = new Segment&lt;K,V&gt;(cap, loadFactor);
}
</code></pre><p>上面代码中的 cap 就是每个 segment 中 HashEntry 数组的长度，它等于 initialCapacity 除以 ssize 的倍数 c，如果 c 大于 1，就会取大于等于 c 的 2 的 N 次方值，所以 cap 不是 1，就是 2 的 N 次方。 segment 的容量 <code>threshold = (int) cap * loadFactor</code>，默认情况下 initialCapacity 等于 16，loadFactor 等于 0.75，通过运算 cap 等于 1，threshold 等于零。</p>
<h5 id="定位segment">定位Segment</h5>
<p>在插入和获取元素的时候，必须先通过散列（hash）算法定位到对应的 Segment。翻源码可以看到，ConcurrentHashMap 中的 hash 算法是单独写的方法，使用的是 Wang/Jenkins hash 的变种算法对元素的 hashCode 进行一次再散列：</p>
<p>复制</p>
<pre><code>private static int hash(int h) {
    // Spread bits to regularize both segment and index locations,
    // using variant of single-word Wang/Jenkins hash.
    h += (h &lt;&lt;  15) ^ 0xffffcd7d;
    h ^= (h &gt;&gt;&gt; 10);
    h += (h &lt;&lt;   3);
    h ^= (h &gt;&gt;&gt;  6);
    h += (h &lt;&lt;   2) + (h &lt;&lt; 14);
    return h ^ (h &gt;&gt;&gt; 16);
}
</code></pre><p>之所以进行再散列，目的是减少散列冲突，使元素能均匀的分布在不同的 Segment 上，从而提高容器的存储效率。假如散列的质量差到极点，所有的元素都在一个 Segment 中，不仅存取元素缓慢，分段锁也会失去意义。</p>
<p>ConcurrentHashMap 通过以下散列算法定位 segment：</p>
<p>复制</p>
<pre><code>final Segment&lt;K,V&gt; segmentFor(int hash) {
    return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];
}
</code></pre><p>在默认情况下，segmentShift 的值为 28，segmentMask 的值为15，再散列后的数的最大是 32 位二进制数据，向右无符号移动 28 位，意思是让高 4 位参与到散列运算中。</p>
<h5 id="get-操作">get 操作</h5>
<p>先看源码：</p>
<p>复制</p>
<pre><code>public V get(Object key) {
    int hash = hash(key.hashCode());
    return segmentFor(hash).get(key, hash); //源码如下
}
</code></pre><p>复制</p>
<pre><code>//Segment类中的get方法
V get(Object key, int hash) {
    if (count != 0) { // read-volatile
        HashEntry&lt;K,V&gt; e = getFirst(hash); //源码如下
        while (e != null) {
            if (e.hash == hash &amp;&amp; key.equals(e.key)) {
                V v = e.value;
                if (v != null)
                    return v;
                return readValueUnderLock(e); // recheck
            }
            e = e.next;
        }
    }
    return null;
}
</code></pre><p>可以看到 get 操作比较简单和高效，先经过一次再 hash，然后使用这个散列值通过散列运算定位到 Segment，再通过散列算法定位到元素。</p>
<p>复制</p>
<pre><code>//定位到具体的HashEntry
HashEntry&lt;K,V&gt; getFirst(int hash) {
    HashEntry&lt;K,V&gt;[] tab = table;
    return tab[hash &amp; (tab.length - 1)];
}
</code></pre><p>这个操作高效的原因是整个 get 操作没有加锁，除非读到的值为空时才会加锁重读。而原理就是使用 volatile 修饰 get 方法中需要用到的共享变量，比如 count 字段和 存储值的 HashEntry 的 value。volatile修饰的变量可以保证可见性，能被多线程同时读并且不会读到过期的值。</p>
<p>复制</p>
<pre><code>transient volatile int count;
volatile V value;
</code></pre><p>在定位元素的代码中可以发现，定位 HashEntry 和 Segment 的散列算法虽然一样，都是与数组的长度减 1 再相与，但是相与的值不一样。定位 segment 使用的是元素的 hashCode 经过再散列后得到的值的高位，而定位 HashEntry 直接使用的是再散列后的值。这么做的目的是避免两次散列后的值一样，虽然元素在 Segment 里面散开了，但是却没有在 HashEntry 中散开。</p>
<h5 id="put-操作">put 操作</h5>
<p>源码：</p>
<p>复制</p>
<pre><code>public V put(K key, V value) {
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key.hashCode());
    return segmentFor(hash).put(key, hash, value, false);  //源码如下
}
</code></pre><p>复制</p>
<pre><code>V put(K key, int hash, V value, boolean onlyIfAbsent) {
    lock();
    try {
        int c = count;
        if (c++ &gt; threshold) // ensure capacity
            rehash();  //大于阈值，需要进行rehash扩容
        HashEntry&lt;K,V&gt;[] tab = table;
        int index = hash &amp; (tab.length - 1);  //定位HashEntry位置
        HashEntry&lt;K,V&gt; first = tab[index];
        HashEntry&lt;K,V&gt; e = first;
        while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key)))
            e = e.next;

        V oldValue;
        //如果对应的key已经有值，覆盖
        if (e != null) {
            oldValue = e.value;
            if (!onlyIfAbsent)
                e.value = value;
        }
        //写入新值
        else {
            oldValue = null;
            ++modCount;
            tab[index] = new HashEntry&lt;K,V&gt;(key, hash, first, value);
            count = c; // write-volatile
        }
        return oldValue;
    } finally {
        unlock();
    }
}
</code></pre><p>put 操作为了线程安全性，首先需要定位到对应的 Segment，并在操作共享变量过程中加锁。插入操作主要有两个步骤：</p>
<ol>
<li>判断 Segment 中的 HashEntry 数组是否需要扩容</li>
<li>定位添加元素的位置，然后将其放到 HashEntry 数组中</li>
</ol>
<p>值得一提的是，Segment 的扩容判断比 HashMap 的扩容判断更加合理，因为 HashMap 是在插入元素后判断元素是否已经达到容量的，如果达到了就进行扩容，但是有可能扩容后并没有新元素进行添加，那么这时候就相当于扩容无效。</p>
<p>复制</p>
<pre><code>void rehash() {
    HashEntry&lt;K,V&gt;[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity &gt;= MAXIMUM_CAPACITY)
        return;

    /*
             * Reclassify nodes in each list to new Map.  Because we are
             * using power-of-two expansion, the elements from each bin
             * must either stay at same index, or move with a power of two
             * offset. We eliminate unnecessary node creation by catching
             * cases where old nodes can be reused because their next
             * fields won't change. Statistically, at the default
             * threshold, only about one-sixth of them need cloning when
             * a table doubles. The nodes they replace will be garbage
             * collectable as soon as they are no longer referenced by any
             * reader thread that may be in the midst of traversing table
             * right now.
             */

    HashEntry&lt;K,V&gt;[] newTable = HashEntry.newArray(oldCapacity&lt;&lt;1);
    threshold = (int)(newTable.length * loadFactor);
    int sizeMask = newTable.length - 1;
    for (int i = 0; i &lt; oldCapacity ; i++) {
        // We need to guarantee that any existing reads of old Map can
        //  proceed. So we cannot yet null out each bin.
        HashEntry&lt;K,V&gt; e = oldTable[i];

        if (e != null) {
            HashEntry&lt;K,V&gt; next = e.next;
            int idx = e.hash &amp; sizeMask;

            //  Single node on list
            if (next == null)
                newTable[idx] = e;

            else {
                // Reuse trailing consecutive sequence at same slot
                HashEntry&lt;K,V&gt; lastRun = e;
                int lastIdx = idx;
                for (HashEntry&lt;K,V&gt; last = next;
                     last != null;
                     last = last.next) {
                    int k = last.hash &amp; sizeMask;
                    if (k != lastIdx) {
                        lastIdx = k;
                        lastRun = last;
                    }
                }
                newTable[lastIdx] = lastRun;

                // Clone all remaining nodes
                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {
                    int k = p.hash &amp; sizeMask;
                    HashEntry&lt;K,V&gt; n = newTable[k];
                    newTable[k] = new HashEntry&lt;K,V&gt;(p.key, p.hash,
                                                     n, p.value);
                }
            }
        }
    }
    table = newTable;
}
</code></pre><h5 id="size-操作">size 操作</h5>
<p>ConcurrentHashMap 统计容量很有意思，统计整个 ConcurrentHashMap 中元素的数量，就必须统计所有 Segment 里元素的大小后求和。Segment 中的全局变量 count 是一个 volatile 变量，那么在多线程环境下，是不是直接把所有 Segment 里的 count 相加就可以得到整个 ConcurrentHashMap 大小了呢？</p>
<p>在多线程环境下显然不是的，虽然相加时可以获取每个 Segment 的 count 最新值，但是可能累加前使用的 count 发生了变化，那么统计结果就不准了，所以，最安全的方法是在统计 size 的时候把所有的 Segment 的 put 、remove 和 clean 方法都锁住，但是这样做显然效率非常低下。</p>
<p>我们看一下源码：</p>
<p>复制</p>
<pre><code>public int size() {
    final Segment&lt;K,V&gt;[] segments = this.segments;
    long sum = 0;
    long check = 0;
    int[] mc = new int[segments.length];
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    for (int k = 0; k &lt; RETRIES_BEFORE_LOCK; ++k) {
        check = 0;
        sum = 0;
        int mcsum = 0;
        for (int i = 0; i &lt; segments.length; ++i) {
            sum += segments[i].count;
            mcsum += mc[i] = segments[i].modCount;
        }
        if (mcsum != 0) {
            for (int i = 0; i &lt; segments.length; ++i) {
                check += segments[i].count;
                if (mc[i] != segments[i].modCount) {
                    check = -1; // force retry
                    break;
                }
            }
        }
        if (check == sum)
            break;
    }
    if (check != sum) { // Resort to locking all segments
        sum = 0;
        for (int i = 0; i &lt; segments.length; ++i)
            segments[i].lock();
        for (int i = 0; i &lt; segments.length; ++i)
            sum += segments[i].count;
        for (int i = 0; i &lt; segments.length; ++i)
            segments[i].unlock();
    }
    if (sum &gt; Integer.MAX_VALUE)
        return Integer.MAX_VALUE;
    else
        return (int)sum;
}
</code></pre><p>其中的常量<code>RETRIES_BEFORE_LOCK</code>在最上面已经提到过，默认值是 2，表示重试次数。我们可以看到，源码中的做法是先尝试 2 次（初始的重试次数）通过不锁住 Segment 的方式来统计各个 Segment 大小，如果统计过程中，容器的 count 发生了变化，再采用加锁的方式来统计所有 Segment 的大小。而判断统计过程中容器是否发生变化是通过 modCount 这个变量感知的，在 put 、remove 和 clean 方法里操作元素前都会将变量 modCount 值加 1，那么在统计 size 前后比较 modCount 是否发生变化，从而得知容器的大小是否发生变化。</p>
<h4 id="jdk-18-源码">JDK 1.8 源码</h4>
<p>JDK 1.8 数据结构见上，为了优化性能，提升并发度，JDK 1.8 开始去掉了 Segment 分段锁机制，直接采取了与 HashMap 相同的数据结构，不同的是为了保证线程安全，采用了 CAS + Synchronized 进行 put 、remove 等操作。</p>
<p>不同于 JDK 1.7 中的 HashEntry 存储键值对，JDK 1.8 中采用了 Node 这个内部类进行键值对的存储。</p>
<p>先看一下 JDK 1.8 中 ConcurrentHashMap 的字段：</p>
<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">含义</th>
<th align="center">初始值</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">MAXIMUM_CAPACITY</td>
<td align="center">最大容量</td>
<td align="center">2^30</td>
</tr>
<tr>
<td align="center">DEFAULT_CAPACITY</td>
<td align="center">默认容量</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">MAX_ARRAY_SIZE</td>
<td align="center">最大数组容量</td>
<td align="center">Integer.MAX_VALUE - 8</td>
</tr>
<tr>
<td align="center">DEFAULT_CONCURRENCY_LEVEL</td>
<td align="center">默认并发度</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">LOAD_FACTOR</td>
<td align="center">负载因子</td>
<td align="center">0.75f</td>
</tr>
</tbody>
</table>
<p>当然还有很多字段，这里只挑一些非常重要的。</p>
<p>JDK 1.8 中 ConcurrentHashMap 比较复杂，但是分析时只分析如何利用 CAS + Synchronized 进行高效的同步更新数据。</p>
<h5 id="put-操作-1">put 操作</h5>
<p>先看源码：</p>
<p>复制</p>
<pre><code>public V put(K key, V value) {
    return putVal(key, value, false); //源码如下
}
</code></pre><p>复制</p>
<pre><code>final V putVal(K key, V value, boolean onlyIfAbsent) {
    //ConcurrentHashMap 不允许插入null键，HashMap允许插入一个null键
    if (key == null || value == null) throw new NullPointerException();
    //计算key的hash值
    int hash = spread(key.hashCode());
    int binCount = 0;
    //for循环的作用：因为更新元素是使用CAS机制更新，需要不断的失败重试，直到成功为止。
    for (Node&lt;K,V&gt;[] tab = table;;) {
        // f：链表或红黑二叉树头结点，向链表中添加元素时，需要synchronized获取f的锁。
        Node&lt;K,V&gt; f; int n, i, fh;
        //判断Node[]数组是否初始化，没有则进行初始化操作
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        //通过hash定位Node[]数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头结点），添加失败则进入下次循环。
        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
            if (casTabAt(tab, i, null,
                         new Node&lt;K,V&gt;(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        //检查到内部正在移动元素（Node[] 数组扩容）
        else if ((fh = f.hash) == MOVED)
            //帮助它扩容
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            //锁住链表或红黑二叉树的头结点
            synchronized (f) {
                //判断f是否是链表的头结点
                if (tabAt(tab, i) == f) {
                    //如果fh&gt;=0 是链表节点
                    if (fh &gt;= 0) {
                        binCount = 1;
                        //遍历链表所有节点
                        for (Node&lt;K,V&gt; e = f;; ++binCount) {
                            K ek;
                            //如果节点存在，则更新value
                            if (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;&amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            //不存在则在链表尾部添加新节点。
                            Node&lt;K,V&gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&lt;K,V&gt;(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    //TreeBin是红黑二叉树节点
                    else if (f instanceof TreeBin) {
                        Node&lt;K,V&gt; p;
                        binCount = 2;
                        //添加树节点
                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                              value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }

            if (binCount != 0) {
                //如果链表长度已经达到临界值8 就需要把链表转换为树结构
                if (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    //将当前ConcurrentHashMap的size数量+1
    addCount(1L, binCount);
    return null;
}
</code></pre><p>简而言之，put 操作的逻辑如下：</p>
<ol>
<li>
<p>判断 Node[] 数组是否初始化，没有则进行初始化操作</p>
</li>
<li>
<p>通过 hash 定位 Node[] 数组的索引坐标，是否有 Node 节点，如果没有则使用 CAS 进行添加（链表的头结点），添加失败则进入下次循环。</p>
</li>
<li>
<p>检查到内部正在扩容，如果正在扩容，就帮助它一块扩容。</p>
</li>
<li>
<p>如果 f != null，则使用 synchronized 锁住 f 元素（链表/红黑二叉树的头元素）</p>
<p>4.1 如果是 Node (链表结构)则执行链表的添加操作。
4.2 如果是 TreeNode (树型结果)则执行树添加操作。</p>
</li>
<li>
<p>判断链表长度已经达到临界值 8 就需要把链表转换为树结构。</p>
<h5 id="get-操作-1">get 操作</h5>
</li>
</ol>
<p>先看源码：</p>
<p>复制</p>
<pre><code>public V get(Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;
    int h = spread(key.hashCode());
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (e = tabAt(tab, (n - 1) &amp; h)) != null) {
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))
                return e.val;
        }
        else if (eh &lt; 0)
            return (p = e.find(h, key)) != null ? p.val : null;
        while ((e = e.next) != null) {
            if (e.hash == h &amp;&amp;
                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
</code></pre><p>还是不加锁，但是同 JDK 1.7 相同，Node 节点中的 value 和 next 都是 volatile 的，即线程对这些数据的修改对其他线程是立马可见的。量的结果-.-，就像loadFactor默认值0.75一样。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" term="java多线程" label="java多线程" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" term="java多线程" label="java多线程" />
                            
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/java/" term="java" label="java" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">HashMap线程不安全的原因</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/hashmap%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8E%9F%E5%9B%A0/" />
            <id>https://example.com/posts/hashmap%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8E%9F%E5%9B%A0/</id>
            <updated>2020-04-24T22:36:35+08:00</updated>
            <published>2019-03-15T16:01:23+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<h3 id="线程不安全的hashmap">线程不安全的HashMap</h3>
<p>HashMap 在日常开发中是十分常见的，也是我们使用 Map 存储键值对的首选类，关于 HashMap 的源码分析可以<a href="%5Bhttps://zyhhh.top/posts/hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%5D(https://zyhhh.top/posts/hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/)">看这里</a>。由于从 JDK 1.8 开始对 HashMap 进行了优化，增加了红黑树这种数据结构，所以 JDK 1.8 的 HashMap 较为复杂，这里为了简化分析，采用 JDK 1.7 版本版本的 HashMap 进行举例说明。</p>……]]></summary>
            
                <content type="html"><![CDATA[<h3 id="线程不安全的hashmap">线程不安全的HashMap</h3>
<p>HashMap 在日常开发中是十分常见的，也是我们使用 Map 存储键值对的首选类，关于 HashMap 的源码分析可以<a href="%5Bhttps://zyhhh.top/posts/hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%5D(https://zyhhh.top/posts/hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/)">看这里</a>。由于从 JDK 1.8 开始对 HashMap 进行了优化，增加了红黑树这种数据结构，所以 JDK 1.8 的 HashMap 较为复杂，这里为了简化分析，采用 JDK 1.7 版本版本的 HashMap 进行举例说明。</p>
<p>HashMap 线程不安全主要体现在两个方面：</p>
<ol>
<li>多线程环境下对键值对进行修改操作（put 和 remove）会出现丢失更新问题</li>
<li>1.7使用的是头插法，使用头插法在多线程扩容的过程可能会造成里面有一个resize方法，它又调用了一个transfer方法，把里面的Entry进行一个rehash,在这个过程中可能会造成一个链表的循环，可能在下一次get时出现死循环的情况，JDK 1.8 已经修复该问题</li>
</ol>
<p>第一种情况下，我们可以先看一下 JDK 1.7 下 HashMap 的源码中的 put 操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">putForNullKey</span><span class="o">(</span><span class="n">value</span><span class="o">)</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">indexFor</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">)</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="o">;</span> <span class="n">e</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Object</span> <span class="n">k</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span><span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="o">(</span><span class="o">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="n">key</span> <span class="o">|</span><span class="o">|</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
            <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="n">e</span><span class="o">.</span><span class="na">recordAccess</span><span class="o">(</span><span class="k">this</span><span class="o">)</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">modCount</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>
    <span class="n">addEntry</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span><span class="o">;</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 put 操作中有一个 addEntry 方法，这是核心方法，其源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="nf">addEntry</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bucketIndex</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//获取头节点，此处在多线程环境下不安全
</span><span class="c1"></span>    <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">bucketIndex</span><span class="o">]</span><span class="o">;</span>
    <span class="n">table</span><span class="o">[</span><span class="n">bucketIndex</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">size</span><span class="o">+</span><span class="o">+</span> <span class="o">&gt;</span><span class="o">=</span> <span class="n">threshold</span><span class="o">)</span>
        <span class="n">resize</span><span class="o">(</span><span class="n">2</span> <span class="o">*</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>现在假如 A 线程和 B 线程同时对同一个数组位置调用 addEntry，两个线程会同时得到现在的头结点，然后 A 写入新的头结点之后，B 也写入新的头结点，那 B 的写入操作就会覆盖 A 的写入操作造成 A 的写入操作丢失。</p>
<p>同理可以看一下 remove 操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">V</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">removeEntryForKey</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">;</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">removeEntryForKey</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="n">key</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">indexFor</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">)</span><span class="o">;</span>
    <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="o">;</span>
    <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">e</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">Object</span> <span class="n">k</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span><span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span><span class="o">&amp;</span>
            <span class="o">(</span><span class="o">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="n">key</span> <span class="o">|</span><span class="o">|</span> <span class="o">(</span><span class="n">key</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">modCount</span><span class="o">+</span><span class="o">+</span><span class="o">;</span>
            <span class="n">size</span><span class="o">-</span><span class="o">-</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">prev</span> <span class="o">=</span><span class="o">=</span> <span class="n">e</span><span class="o">)</span>
                <span class="n">table</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">prev</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="n">e</span><span class="o">.</span><span class="na">recordRemoval</span><span class="o">(</span><span class="k">this</span><span class="o">)</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当多个线程同时操作同一个数组位置的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写会到该数组位置去，其实写回的时候可能其他的线程已经就把这个位置给修改过了，就会覆盖其他线程的修改，也就是丢失修改问题。</p>
<p><strong>第二种情况中</strong>，我们可以看一下 resize 操作的源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="nf">resize</span><span class="o">(</span><span class="kt">int</span> <span class="n">newCapacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Entry</span><span class="o">[</span><span class="o">]</span> <span class="n">oldTable</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">oldCapacity</span> <span class="o">=</span> <span class="n">oldTable</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">oldCapacity</span> <span class="o">=</span><span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">Entry</span><span class="o">[</span><span class="o">]</span> <span class="n">newTable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Entry</span><span class="o">[</span><span class="n">newCapacity</span><span class="o">]</span><span class="o">;</span>
    <span class="n">transfer</span><span class="o">(</span><span class="n">newTable</span><span class="o">,</span> <span class="n">initHashSeedAsNeeded</span><span class="o">(</span><span class="n">newCapacity</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">;</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">newCapacity</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">,</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">+</span> <span class="n">1</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**
</span><span class="cm"> * Transfers all entries from current table to newTable.
</span><span class="cm"> */</span>
<span class="c1">// 关键在于这个transfer方法，这个方法的作用是将旧hash表中的元素rehash到新的hash表中
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">transfer</span><span class="o">(</span><span class="n">Entry</span><span class="o">[</span><span class="o">]</span> <span class="n">newTable</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">rehash</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">table</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// table变量即为旧hash表
</span><span class="c1"></span>        <span class="k">while</span><span class="o">(</span><span class="kc">null</span> <span class="o">!</span><span class="o">=</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// #1
</span><span class="c1"></span>            <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">rehash</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span> <span class="kc">null</span> <span class="o">=</span><span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">hash</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 用元素的hash值计算出这个元素在新hash表中的位置
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">indexFor</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span><span class="o">,</span> <span class="n">newCapacity</span><span class="o">)</span><span class="o">;</span>
            <span class="c1">// #2
</span><span class="c1"></span>            <span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newTable</span><span class="o">[</span><span class="n">I</span><span class="o">]</span><span class="o">;</span>
            <span class="c1">// #3
</span><span class="c1"></span>            <span class="n">newTable</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="c1">// #4
</span><span class="c1"></span>            <span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>假设线程 1 (t1)和线程 2 (t2)同时 resize，两个线程 resize 前，两个线程及 HashMap 的状态如下 ：</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200424223221.png" alt=""></p>
<p>堆内存中的 HashMap 对象中的 table 字段指向旧的 hash 表，其中 index 为 7 的位置有两个元素，我们以这两个元素的 rehash 为例，看看循环链表是如何形成的。</p>
<p>线程 1 和线程 2 分别 new 了一个 hash 表，用 newTable 字段表示。</p>
<p><strong>Step1</strong>: t2 执行完 #1 代码后，CPU且走执行 t1，并且 t1 执行完成</p>
<p>这里可以根据上图推算一下，此时状态如下 ：</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200424223232.png" alt=""></p>
<p>用 t2.e 表示线程 2 中的局部变量 e，t2.next 同理。</p>
<p><strong>Step2</strong>: t2 继续向下执行完本次循环</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200424223318.png" alt=""></p>
<p><strong>Step3</strong>: t2 继续执行下一次循环</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200424223332.png" alt=""></p>
<p><strong>Step4</strong>: t2继续下一次循环，循环链表出现</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200424223347.png" alt=""></p>
<p>然后我们在这个时候进行一个 get 操作，get 方法源码如下：</p>
<p>复制</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">getForNullKey</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">getEntry</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">;</span>

    <span class="k">return</span> <span class="kc">null</span> <span class="o">=</span><span class="o">=</span> <span class="n">entry</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">final</span> <span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">getEntry</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">=</span><span class="o">=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="o">(</span><span class="n">key</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">;</span>
    <span class="c1">// 遍历链表
</span><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="n">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">table</span><span class="o">[</span><span class="n">indexFor</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span><span class="o">)</span><span class="o">]</span><span class="o">;</span>
         <span class="n">e</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
         <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Object</span> <span class="n">k</span><span class="o">;</span>
        <span class="c1">// 假设这里条件一直不成立
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span><span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span><span class="o">&amp;</span>
            <span class="o">(</span><span class="o">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="n">key</span> <span class="o">|</span><span class="o">|</span> <span class="o">(</span><span class="n">key</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>由上图可知，for 循环中的 <code>e = e.next</code>永远不会为空，那么，如果 get 一个在这个链表中不存在的 key 时，就会出现死循环了。</p>
<h3 id="实现线程安全">实现线程安全</h3>
<p>那么如何在多线程环境下使用线程安全的 HashMap 呢？</p>
<p>可以有一下解决方法：</p>
<ul>
<li>使用 Collections.synchronizedMap(Map&lt;K,V&gt; ) 方法把 HashMap 变成一个线程安全的 Map</li>
<li>使用 Hashtable、ConcurrentHashMap 这两个线程安全的 Map</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" term="java多线程" label="java多线程" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" term="java多线程" label="java多线程" />
                            
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/java/" term="java" label="java" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">HashMap源码分析</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" />
            <id>https://example.com/posts/hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
            <updated>2020-04-24T22:48:07+08:00</updated>
            <published>2019-03-14T16:01:23+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<blockquote>
<p><code>HashMap</code>最早出现在JDK1.2中，底层基于散列算法（Hash）实现。并且<code>HashMap</code>允许null键和null值，是线程非安全类，在多线程环境下可能会存在问题，与之对应的是<code>HashTable</code>类，<code>HashTable</code>是线程安全的<code>HashMap</code>，但是在之前由于HashTable方法都是用<code>synchronized</code>实现，开销比较大，所以在多线程时反而并不使用<code>HashTable</code>，而是使用<code>CurrentHashMap</code>。在JDK1.8后，<code>HashMap</code>和<code>CurrentHashMap</code>的数据结构都有了新变化，即加入了红黑树。</p>
</blockquote>
<h3 id="jdk17及之前版本中的hashmap数据结构">JDK1.7及之前版本中的HashMap数据结构</h3>……]]></summary>
            
                <content type="html"><![CDATA[<blockquote>
<p><code>HashMap</code>最早出现在JDK1.2中，底层基于散列算法（Hash）实现。并且<code>HashMap</code>允许null键和null值，是线程非安全类，在多线程环境下可能会存在问题，与之对应的是<code>HashTable</code>类，<code>HashTable</code>是线程安全的<code>HashMap</code>，但是在之前由于HashTable方法都是用<code>synchronized</code>实现，开销比较大，所以在多线程时反而并不使用<code>HashTable</code>，而是使用<code>CurrentHashMap</code>。在JDK1.8后，<code>HashMap</code>和<code>CurrentHashMap</code>的数据结构都有了新变化，即加入了红黑树。</p>
</blockquote>
<h3 id="jdk17及之前版本中的hashmap数据结构">JDK1.7及之前版本中的HashMap数据结构</h3>
<p>在JDK1.6，1.7中，HashMap都是基于“拉链法”实现，即数组+链表的形式，通过不同的hash值来对键分配不同的桶（bucket）。数据节点为Entry节点，数据插入使用头插法，是线程不安全的原因之一。</p>
<h3 id="jdk18版本的hashmap数据结构">JDK1.8版本的HashMap数据结构</h3>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200415155353.png" alt=""></p>
<p>在JDK1.8中对HashMap的源码进行了优化，在JDK1.7中，HashMap处理“碰撞”的时候，都是采用链表来存储，当碰撞的节点很多的时候，查询时间复杂度从原来的O(1)变成了O(N)。而JDK1.8中，为了优化这种情况，HashMap处理“碰撞”增加了红黑树这种数据结构，当碰撞节点较少时，采样链表存储，当较大（默认是超过8）时，变成使用红黑树（特点是查询时间是O(logN)）存储。</p>
<h4 id="结构">结构</h4>
<p><code>Node</code>是HashMap中的一个静态内部类：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//Node是单向链表，实现了Map.Entry接口
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
 	<span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span> <span class="c1">//哈希
</span><span class="c1"></span> 	<span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="o">;</span>  <span class="c1">//键值对
</span><span class="c1"></span>   <span class="n">V</span> <span class="n">value</span><span class="o">;</span>
 	<span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>  <span class="c1">//下一个节点
</span><span class="c1"></span>    
	 <span class="c1">//构造函数
</span><span class="c1"></span>  <span class="n">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
	 <span class="k">this</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">;</span>
 	 <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
 	 <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
 	 <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
 	<span class="o">}</span>

 	<span class="c1">// getter and setter ... toString ...
</span><span class="c1"></span> 	<span class="kd">public</span> <span class="kd">final</span> <span class="n">K</span> <span class="nf">getKey</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">key</span><span class="o">;</span> <span class="o">}</span>
 	<span class="kd">public</span> <span class="kd">final</span> <span class="n">V</span> <span class="nf">getValue</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
 	<span class="kd">public</span> <span class="kd">final</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">key</span> <span class="o">+</span> <span class="s">&#34;=&#34;</span> <span class="o">+</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>

	<span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
 	<span class="k">return</span> <span class="n">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">^</span> <span class="n">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>

 <span class="kd">public</span> <span class="kd">final</span> <span class="n">V</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">V</span> <span class="n">newValue</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
 <span class="o">}</span>

 <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
 	<span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">=</span><span class="o">=</span> <span class="k">this</span><span class="o">)</span>
 	   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
 	<span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="o">{</span>
 	   <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="o">?</span><span class="o">,</span><span class="o">?</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="o">?</span><span class="o">,</span><span class="o">?</span><span class="o">&gt;</span><span class="o">)</span><span class="n">o</span><span class="o">;</span>
 	<span class="k">if</span> <span class="o">(</span><span class="n">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">&amp;</span><span class="o">&amp;</span>
 	   <span class="n">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
 	   <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>TreeNode</code>是红黑树的数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">LinkedHashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
 	<span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">parent</span><span class="o">;</span> <span class="c1">// red-black tree links
</span><span class="c1"></span> 	<span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">left</span><span class="o">;</span>
 	<span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">right</span><span class="o">;</span>
 	<span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">;</span> <span class="c1">// needed to unlink next upon deletion
</span><span class="c1"></span> 	<span class="kt">boolean</span> <span class="n">red</span><span class="o">;</span>
 	<span class="n">TreeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">val</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
 	<span class="kd">super</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">next</span><span class="o">)</span><span class="o">;</span>
 <span class="o">}</span>

 <span class="cm">/**
</span><span class="cm">     * Returns root of tree containing this node.
</span><span class="cm">     */</span>
 <span class="kd">final</span> <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">root</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
 	<span class="k">for</span> <span class="o">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="k">this</span><span class="o">,</span> <span class="n">p</span><span class="o">;</span><span class="o">;</span><span class="o">)</span> <span class="o">{</span>
 		<span class="k">if</span> <span class="o">(</span><span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
 			<span class="k">return</span> <span class="n">r</span><span class="o">;</span>
         <span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
 	<span class="o">}</span>
 <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="类定义">类定义</h4>
<pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable
</code></pre><h4 id="变量">变量</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-Java" data-lang="Java"><span class="cm">/**
</span><span class="cm"> * 默认初始容量16(必须是2的幂次方)
</span><span class="cm"> */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">4</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * 最大容量，2的30次方
</span><span class="cm"> */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">=</span> <span class="n">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">30</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * 默认加载因子，用来计算threshold
</span><span class="cm"> */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">float</span> <span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">=</span> <span class="n">0</span><span class="o">.</span><span class="na">75f</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * 链表转成树的阈值，当桶中链表长度大于8时转成树 
</span><span class="cm">   threshold = capacity * loadFactor
</span><span class="cm"> */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="n">8</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * 进行resize操作时，若桶中数量少于6则从树转成链表
</span><span class="cm"> */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">UNTREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="n">6</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * 桶中结构转化为红黑树对应的table的最小大小
</span><span class="cm">   当需要将解决 hash 冲突的链表转变为红黑树时，
</span><span class="cm">   需要判断下此时数组容量，
</span><span class="cm">   若是由于数组容量太小（小于　MIN_TREEIFY_CAPACITY　）
</span><span class="cm">   导致的 hash 冲突太多，则不进行链表转变为红黑树操作，
</span><span class="cm">   转为利用　resize() 函数对　hashMap 扩容
</span><span class="cm"> */</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MIN_TREEIFY_CAPACITY</span> <span class="o">=</span> <span class="n">64</span><span class="o">;</span>
<span class="cm">/**
</span><span class="cm"> 保存Node&lt;K,V&gt;节点的数组
</span><span class="cm"> 该表在首次使用时初始化，并根据需要调整大小。 分配时，
</span><span class="cm"> 长度始终是2的幂。
</span><span class="cm"> */</span>
<span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span><span class="o">[</span><span class="o">]</span> <span class="n">table</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * 存放具体元素的集
</span><span class="cm"> */</span>
<span class="kd">transient</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">entrySet</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * 记录 hashMap 当前存储的元素的数量
</span><span class="cm"> */</span>
<span class="kd">transient</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * 每次更改map结构的计数器
</span><span class="cm"> */</span>
<span class="kd">transient</span> <span class="kt">int</span> <span class="n">modCount</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容
</span><span class="cm"> */</span>
<span class="kt">int</span> <span class="n">threshold</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * 负载因子：要调整大小的下一个大小值（容量*加载因子）。
</span><span class="cm"> */</span>
<span class="kd">final</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="构造方法">构造方法</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 初始容量不能小于0，否则报错
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Illegal initial capacity: &#34;</span> <span class="o">+</span> <span class="n">initialCapacity</span><span class="o">)</span><span class="o">;</span>
    <span class="c1">// 初始容量不能大于最大值，否则为最大值
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span>
        <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">;</span>
    
    <span class="c1">//负载因子不能小于或等于0，不能为非数字
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">loadFactor</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">0</span> <span class="o">|</span><span class="o">|</span> <span class="n">Float</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">)</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;Illegal load factor: &#34;</span> <span class="o">+</span> <span class="n">loadFactor</span><span class="o">)</span><span class="o">;</span>
    
    <span class="c1">// 初始化负载因子                                        
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">loadFactor</span><span class="o">;</span>
    
    <span class="c1">// 初始化threshold大小
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">)</span><span class="o">;</span>    
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 调用HashMap(int, float)型构造函数
</span><span class="c1"></span>    <span class="k">this</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">,</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 初始化填充因子，此处说明HashMap也是采用延迟加载的方式，首次使用时才会进行加载
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">;</span>
        
<span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="o">?</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 初始化填充因子
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="o">;</span>
    <span class="c1">// 将m中的所有元素添加至HashMap中
</span><span class="c1"></span>    <span class="n">putMapEntries</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
    
<span class="c1">//putMapEntries(Map m, boolean evict)函数将m的所有元素存入本HashMap实例中。
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">void</span> <span class="nf">putMapEntries</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="o">?</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
<span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
   <span class="c1">// 判断table是否已经初始化
</span><span class="c1"></span>   <span class="k">if</span> <span class="o">(</span><span class="n">table</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// pre-size
</span><span class="c1"></span>       <span class="c1">// 未初始化，s为m的实际元素个数
</span><span class="c1"></span>       <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">(</span><span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">s</span> <span class="o">/</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">.</span><span class="na">0F</span><span class="o">;</span>
       <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="o">(</span><span class="n">ft</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">ft</span> <span class="o">:</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span><span class="o">;</span>
            <span class="c1">// 计算得到的t大于阈值，则初始化阈值
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="o">(</span><span class="n">t</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 已初始化，并且m元素个数大于阈值，进行扩容处理
</span><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
            <span class="n">resize</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="c1">// 将m中的所有元素添加至HashMap中
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="o">?</span> <span class="kd">extends</span> <span class="n">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">.</span><span class="na">entrySet</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">K</span> <span class="n">key</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="n">V</span> <span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="n">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">evict</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="tablesizefor方法详解">tableSizeFor方法详解</h4>
<p>用位运算找到大于或等于cap的最小2的整次幂的数，比如10，则返回16。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">tableSizeFor</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">|</span><span class="o">=</span> <span class="n">n</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">1</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">|</span><span class="o">=</span> <span class="n">n</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">2</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">|</span><span class="o">=</span> <span class="n">n</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">4</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">|</span><span class="o">=</span> <span class="n">n</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">8</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">|</span><span class="o">=</span> <span class="n">n</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">16</span><span class="o">;</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">1</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span><span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">:</span> <span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>让cap-1再赋值给n的目的是使得找到的目标值大于或等于原值。例如二进制<code>0100</code>,十进制是4,若不减1而直接操作，答案是<code>0001 0000</code>十进制是16，明显不符合预期。</li>
<li>对n右移1位：001xx…xxx，再位或：011xx…xxx</li>
<li>对n右移2位：00011…xxx，再位或：01111…xxx</li>
<li>对n右移4位…</li>
<li>对n右移8位…</li>
<li>对n右移16位,因为int最大就<code>2^32</code>所以移动1、2、4、8、16位并取位或,会将最高位的1后面的位全变为1。</li>
<li>再让结果n+1，即得到了2的整数次幂的值了。</li>
</ol>
<p>附带一个实例：</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200424224740.png" alt=""></p>
<h4 id="loadfactory负载因子">loadFactory负载因子</h4>
<p><strong>对于HashMap来说，负载因子是一个很重要的参数，该参数反应了HashMap桶数组的使用情况，通过调节负载因子，可以使HashMap时间和空间复杂度上有不同的表现。</strong></p>
<p>当我们调低负载因子时，HashMap 所能容纳的键值对数量变少。扩容时，重新将键值对存储新的桶数组里，键的键之间产生的碰撞会下降，链表长度变短。此时，HashMap 的增删改查等操作的效率将会变高，这里是典型的拿空间换时间。</p>
<p>相反，如果增加负载因子（负载因子可以大于1），HashMap 所能容纳的键值对数量变多，空间利用率高，但碰撞率也高。这意味着链表长度变长，效率也随之降低，这种情况是拿时间换空间。至于负载因子怎么调节，这个看使用场景了。</p>
<p>一般情况下，我们用默认值就可以了。大多数情况下0.75在时间跟空间代价上达到了平衡所以不建议修改。</p>
<h4 id="查找">查找</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">V</span> <span class="nf">get</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
   <span class="k">return</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">,</span> <span class="n">key</span><span class="o">)</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">// HashMap中的Hash方法
</span><span class="c1"></span><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
   <span class="kt">int</span> <span class="n">h</span><span class="o">;</span>
 <span class="c1">// 拿到key的hash值后与其无符号右移16位取“与”
</span><span class="c1"></span> <span class="c1">// 这种方式能混合原始hash值的高位和低位，并且混合后的低位混杂了高位的特征
</span><span class="c1"></span> <span class="c1">// 主要是考虑数组的table的length比较小的时候也能保证考虑到高低bit都能参与到hash中，并且效率很高
</span><span class="c1"></span> <span class="c1">// 通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中。
</span><span class="c1"></span>  <span class="k">return</span> <span class="o">(</span><span class="n">key</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">16</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="nf">getNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
 	<span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span><span class="o">[</span><span class="o">]</span> <span class="n">tab</span><span class="o">;</span> 
 	<span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">,</span> <span class="n">e</span><span class="o">;</span> 
 	<span class="kt">int</span> <span class="n">n</span><span class="o">;</span> <span class="n">K</span> <span class="n">k</span><span class="o">;</span>
 <span class="c1">// 定位键值对所在桶的位置
</span><span class="c1"></span> <span class="k">if</span> <span class="o">(</span><span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;</span><span class="o">&amp;</span>  <span class="o">(</span><span class="n">first</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">]</span><span class="o">)</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
 <span class="c1">// 判断桶中第一项(数组元素)相等
</span><span class="c1"></span> <span class="k">if</span> <span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span><span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="c1">// always check first node
</span><span class="c1"></span>     <span class="o">(</span><span class="o">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="n">key</span> <span class="o">|</span><span class="o">|</span> <span class="o">(</span><span class="n">key</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
 		<span class="k">return</span> <span class="n">first</span><span class="o">;</span>
 <span class="c1">// 桶中不止一个结点
</span><span class="c1"></span> <span class="k">if</span> <span class="o">(</span><span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
 <span class="c1">// 是否是红黑树，是的话调用getTreeNode方法
</span><span class="c1"></span> <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
 	<span class="k">return</span> <span class="o">(</span><span class="o">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span><span class="o">)</span><span class="n">first</span><span class="o">)</span><span class="o">.</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">)</span><span class="o">;</span>
 <span class="c1">// 不是红黑树的话，在链表中遍历查找    
</span><span class="c1"></span> <span class="k">do</span> <span class="o">{</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span><span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="o">(</span><span class="o">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="n">key</span> <span class="o">|</span><span class="o">|</span> <span class="o">(</span><span class="n">key</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
 	<span class="k">return</span> <span class="n">e</span><span class="o">;</span>
 <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span><span class="o">;</span>
 	<span class="o">}</span>
 <span class="o">}</span>
 	<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>HashMap：如何有效减少碰撞</p>
<ol>
<li>扰动函数：促使元素位置分布均匀，减少碰撞几率</li>
<li>使用final对象，并采用合适的equals()和hashCode()方法</li>
</ol>
<p>注意：</p>
<ol>
<li>
<p>HashMap的hash算法(<code>hash()</code>方法)。</p>
</li>
<li>
<p><code>(n - 1) &amp; hash</code>等价于对 length 取余。</p>
<h4 id="添加">添加</h4>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">V</span> <span class="nf">put</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
   <span class="c1">// 调用hash(key)方法来计算hash 
</span><span class="c1"></span>   <span class="k">return</span> <span class="n">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">final</span> <span class="n">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span><span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span><span class="o">[</span><span class="o">]</span> <span class="n">tab</span><span class="o">;</span> 
   <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span> 
   <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
   <span class="c1">// 容量初始化：当table为空，则调用resize()方法来初始化容器，并且resize()方法可以扩容
</span><span class="c1"></span>   <span class="k">if</span> <span class="o">(</span><span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span> <span class="o">|</span><span class="o">|</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="n">0</span><span class="o">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
   <span class="c1">//确定元素存放在哪个桶中，桶为空，新生成结点放入桶中
</span><span class="c1"></span>   <span class="k">if</span> <span class="o">(</span><span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">]</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span><span class="o">;</span>
   <span class="k">else</span> <span class="o">{</span>
   <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span> <span class="n">K</span> <span class="n">k</span><span class="o">;</span>
   <span class="c1">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等
</span><span class="c1"></span>   <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span><span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span><span class="o">&amp;</span>  <span class="o">(</span><span class="o">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="n">key</span> <span class="o">|</span><span class="o">|</span> <span class="o">(</span><span class="n">key</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
   <span class="c1">//如果键的值以及节点 hash 等于链表中的第一个键值对节点时，则将 e 指向该键值对
</span><span class="c1"></span>       <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
   <span class="c1">// 如果桶中的引用类型为 TreeNode，则调用红黑树的插入方法
</span><span class="c1"></span>   <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
   <span class="c1">// 放入树中
</span><span class="c1"></span>        <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="o">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span><span class="o">)</span><span class="n">p</span><span class="o">)</span><span class="o">.</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span><span class="o">;</span>
   <span class="k">else</span> <span class="o">{</span>
   <span class="c1">//对链表进行遍历，并统计链表长度
</span><span class="c1"></span>   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="o">;</span> <span class="o">+</span><span class="o">+</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
   <span class="c1">// 到达链表的尾部
</span><span class="c1"></span>   <span class="k">if</span> <span class="o">(</span><span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
   <span class="c1">//在尾部插入新结点
</span><span class="c1"></span>       <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span><span class="o">;</span>
   <span class="c1">// 如果结点数量达到阈值，转化为红黑树
</span><span class="c1"></span>   <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;</span><span class="o">=</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span> <span class="c1">// -1 for 1st
</span><span class="c1"></span>       <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">)</span><span class="o">;</span>
       <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
   <span class="c1">// 判断链表中结点的key值与插入的元素的key值是否相等
</span><span class="c1"></span>   <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span><span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span><span class="o">&amp;</span>  <span class="o">(</span><span class="o">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="n">key</span> <span class="o">|</span><span class="o">|</span> <span class="o">(</span><span class="n">key</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
        <span class="k">break</span><span class="o">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
      <span class="o">}</span>
   <span class="o">}</span>
   <span class="c1">//判断要插入的键值对是否存在 HashMap 中
</span><span class="c1"></span>   <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// existing mapping for key
</span><span class="c1"></span>       <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
   <span class="c1">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值
</span><span class="c1"></span>   <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">onlyIfAbsent</span> <span class="o">|</span><span class="o">|</span> <span class="n">oldValue</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
       <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
       <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">)</span><span class="o">;</span>
       <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
    <span class="o">}</span>
 <span class="o">}</span>
   <span class="o">+</span><span class="o">+</span><span class="n">modCount</span><span class="o">;</span>
   <span class="c1">// 键值对数量超过阈值时，则进行扩容
</span><span class="c1"></span>   <span class="k">if</span> <span class="o">(</span><span class="o">+</span><span class="o">+</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
     <span class="n">resize</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
     <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">)</span><span class="o">;</span>
     <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>事实上，<code>new HashMap();</code>完成后，如果没有<code>put</code>操作，是不会分配存储空间的。</p>
<p>HashMap：put方法的逻辑</p>
<ol>
<li>如果HashMap未被初始化过，则初始化</li>
<li>对key求hash值，然后再计算下标</li>
<li>如果没有碰撞，直接放入桶中</li>
<li>如果碰撞了，以链表的方式链接到后面</li>
<li>如果链表长度超过阈值，就把链表转换成红黑树</li>
<li>如果链表的长度低于6，就把红黑树转回链表</li>
<li>如果节点已经存在就替换旧值</li>
<li>如果桶满了（容量16*负载因子0.75），就需要resize（扩容2倍后重排）</li>
</ol>
<h4 id="扩容机制">扩容机制</h4>
<p>在 HashMap 中，桶数组的长度均是2的幂，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容。 HashMap 按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span><span class="o">[</span><span class="o">]</span> <span class="nf">resize</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
 <span class="c1">// 拿到数组桶
</span><span class="c1"></span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span><span class="o">[</span><span class="o">]</span> <span class="n">oldTab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
 <span class="kt">int</span> <span class="n">oldCap</span> <span class="o">=</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">oldTab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
 <span class="kt">int</span> <span class="n">oldThr</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">;</span>
 <span class="kt">int</span> <span class="n">newCap</span><span class="o">,</span> <span class="n">newThr</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
 <span class="c1">// 如果数组桶的容量大与0
</span><span class="c1"></span> <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
 <span class="c1">// 如果比最大值还大，则赋值为最大值
</span><span class="c1"></span> <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;</span><span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
 <span class="k">return</span> <span class="n">oldTab</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="c1">// 如果扩容后小于最大值 而且 旧数组桶大于初始容量16， 阈值左移1(扩大2倍)
</span><span class="c1"></span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="o">(</span><span class="n">newCap</span> <span class="o">=</span> <span class="n">oldCap</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;</span><span class="o">&amp;</span>
                 <span class="n">oldCap</span> <span class="o">&gt;</span><span class="o">=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">)</span>
            <span class="n">newThr</span> <span class="o">=</span> <span class="n">oldThr</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">1</span><span class="o">;</span> <span class="c1">// double threshold
</span><span class="c1"></span> <span class="o">}</span>
 <span class="c1">// 如果数组桶容量&lt;=0 且 旧阈值 &gt;0
</span><span class="c1"></span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">oldThr</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// initial capacity was placed in threshold
</span><span class="c1"></span> <span class="c1">// 新容量=旧阈值
</span><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">oldThr</span><span class="o">;</span>
 <span class="c1">// 如果数组桶容量&lt;=0 且 旧阈值 &lt;=0
</span><span class="c1"></span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// zero initial threshold signifies using defaults
</span><span class="c1"></span> <span class="c1">// 新容量=默认容量
</span><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">;</span>
 <span class="c1">// 新阈值= 负载因子*默认容量
</span><span class="c1"></span>        <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="o">(</span><span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">*</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">)</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="c1">// 如果新阈值为0
</span><span class="c1"></span> <span class="k">if</span> <span class="o">(</span><span class="n">newThr</span> <span class="o">=</span><span class="o">=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
 <span class="c1">// 重新计算阈值
</span><span class="c1"></span> <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">newCap</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">;</span>
        <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">ft</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">MAXIMUM_CAPACITY</span> <span class="o">?</span>
 <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">ft</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="c1">// 更新阈值
</span><span class="c1"></span>    <span class="n">threshold</span> <span class="o">=</span> <span class="n">newThr</span><span class="o">;</span>
 <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="o">{</span><span class="s">&#34;rawtypes&#34;</span><span class="o">,</span><span class="s">&#34;unchecked&#34;</span><span class="o">}</span><span class="o">)</span>
 <span class="c1">// 创建新数组
</span><span class="c1"></span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span><span class="o">[</span><span class="o">]</span> <span class="n">newTab</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span><span class="o">[</span><span class="o">]</span><span class="o">)</span><span class="k">new</span> <span class="n">Node</span><span class="o">[</span><span class="n">newCap</span><span class="o">]</span><span class="o">;</span>
 <span class="c1">// 覆盖数组桶    
</span><span class="c1"></span>    <span class="n">table</span> <span class="o">=</span> <span class="n">newTab</span><span class="o">;</span>
 <span class="c1">// 如果旧数组桶不是空，则遍历桶数组，并将键值对映射到新的桶数组中
</span><span class="c1"></span> <span class="k">if</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oldCap</span><span class="o">;</span> <span class="o">+</span><span class="o">+</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
 <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
 <span class="k">if</span> <span class="o">(</span><span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="o">)</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">newTab</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
 <span class="c1">// 如果是红黑树
</span><span class="c1"></span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
 <span class="c1">// 重新映射时，需要对红黑树进行拆分
</span><span class="c1"></span> <span class="o">(</span><span class="o">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span><span class="o">)</span><span class="n">e</span><span class="o">)</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">newTab</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">oldCap</span><span class="o">)</span><span class="o">;</span>
 <span class="k">else</span> <span class="o">{</span> <span class="c1">// preserve order
</span><span class="c1"></span> <span class="c1">// 如果不是红黑树，则按链表处理
</span><span class="c1"></span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">loHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
 <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">hiHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
 <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
 <span class="c1">// 遍历链表，并将链表节点按原顺序进行分组
</span><span class="c1"></span> <span class="k">do</span> <span class="o">{</span>
 <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
 <span class="k">if</span> <span class="o">(</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">oldCap</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
     <span class="n">loHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
 <span class="k">else</span>
     <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
     <span class="n">loTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="k">else</span> <span class="o">{</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
     <span class="n">hiHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
 <span class="k">else</span>
     <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
     <span class="n">hiTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
   <span class="o">}</span>
 <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">)</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span><span class="o">;</span>
 <span class="c1">// 将分组后的链表映射到新桶中
</span><span class="c1"></span> <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
     <span class="n">newTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
     <span class="n">newTab</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">oldCap</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="o">;</span>
 		<span class="o">}</span>
 	   <span class="o">}</span>
 	  <span class="o">}</span>
    <span class="o">}</span>
 <span class="o">}</span>
 	<span class="k">return</span> <span class="n">newTab</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>说明：进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p>
<p>HashMap扩容问题：</p>
<ol>
<li>多线程环境下，调整大小会存在条件竞争，容易造成死锁</li>
<li>rehashing是一个比较耗时的过程</li>
</ol>
<p>整体步骤：</p>
<ol>
<li>计算新桶数组的容量 newCap 和新阈值 newThr</li>
<li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li>
<li>将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。</li>
</ol>
<p>总结起来，一共有三种<strong>扩容方式</strong>：</p>
<ol>
<li>使用默认构造方法初始化HashMap。从前文可以知道HashMap在一开始初始化的时候会返回一个空的table，并且thershold为0。因此第一次扩容的容量为默认值<code>DEFAULT_INITIAL_CAPACITY</code>也就是16。同时<code>threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 12</code>。</li>
<li>指定初始容量的构造方法初始化<code>HashMap</code>。那么从下面源码可以看到初始容量会等于<code>threshold</code>，接着<code>threshold = 当前的容量（threshold） * DEFAULT_LOAD_FACTOR</code>。</li>
<li>HashMap不是第一次扩容。如果<code>HashMap</code>已经扩容过的话，那么每次table的容量以及<code>threshold</code>量为原有的两倍。</li>
</ol>
<p>细心点的人会很好奇，为什么要判断loadFactor为0呢？</p>
<blockquote>
<p>loadFactor小数位为 0，整数位可被2整除且大于等于8时，在某次计算中就可能会导致 newThr 溢出归零。</p>
</blockquote>
<h3 id="疑问和进阶">疑问和进阶</h3>
<p><strong>1. JDK1.7是基于数组+单链表实现（为什么不用双链表）</strong></p>
<p>首先，用链表是为了解决hash冲突。</p>
<p>单链表能实现为什么要用双链表呢?(双链表需要更大的存储空间)</p>
<p><strong>2. 为什么要用红黑树，而不用平衡二叉树？</strong></p>
<blockquote>
<p>插入效率比平衡二叉树高，查询效率比普通二叉树高。所以选择性能相对折中的红黑树。</p>
</blockquote>
<p><strong>3. 重写对象的Equals方法时，要重写hashCode方法，为什么？跟HashMap有什么关系？</strong></p>
<p>equals与hashcode间的关系:</p>
<ol>
<li>如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同；</li>
<li>如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)</li>
</ol>
<p>因为在 HashMap 的链表结构中遍历判断的时候，特定情况下重写的 equals 方法比较对象是否相等的业务逻辑比较复杂，循环下来更是影响查找效率。所以这里把 hashcode 的判断放在前面，只要 hashcode 不相等就玩儿完，不用再去调用复杂的 equals 了。很多程度地提升 HashMap 的使用效率。</p>
<p>所以重写 hashcode 方法是为了让我们能够正常使用 HashMap 等集合类，因为 HashMap 判断对象是否相等既要比较 hashcode 又要使用 equals 比较。而这样的实现是为了提高 HashMap 的效率。</p>
<p><strong>4. HashMap为什么不直接使用对象的原始hash值呢?</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
 <span class="kt">int</span> <span class="n">h</span><span class="o">;</span>
 <span class="k">return</span> <span class="o">(</span><span class="n">key</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">16</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们发现，HashMap的哈希值是通过上面的方式获取，而不是通过<code>key.hashCode()</code>方法获取。</p>
<p>原因：</p>
<blockquote>
<p>通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。</p>
</blockquote>
<p><strong>5. 既然红黑树那么好，为啥hashmap不直接采用红黑树，而是当大于8个的时候才转换红黑树？</strong></p>
<p>因为红黑树需要进行左旋，右旋操作， 而单链表不需要。</p>
<p>以下都是单链表与红黑树结构对比。</p>
<p>如果元素小于8个，查询成本高，新增成本低。</p>
<p>如果元素大于8个，查询成本低，新增成本高。</p>
<p>至于为什么选数字8，是大佬折中衡量的结果-.-，就像loadFactor默认值0.75一样。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" term="java多线程" label="java多线程" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" term="java多线程" label="java多线程" />
                            
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/java/" term="java" label="java" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">给博客添加一个live2d看板娘</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/live2d/" />
            <id>https://example.com/posts/live2d/</id>
            <updated>2020-04-13T00:22:29+08:00</updated>
            <published>2019-03-02T01:53:34+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<h2 id="live2d-是什么">Live2d 是什么</h2>
<p>Live2d 的官网地址：https://www.live2d.com/zh-CHS/</p>
<p>Live2d 是一种 <code>2d</code> 的绘图渲染技术，是由日本的一个叫 <code>Cybernoids</code> 的公司开发，通过一系列可以连续动画的的人物或者动物来建立模型，生成一种可以动的 <code>2d</code> 图形或者说二维模型。这种模型和二次元很接近，所以喜欢这种风格的人很多，但是也有它自身的缺陷那就是不容易商业化和更快的发展，例如现在的 <code>3d</code> 模型在游戏上和 <code>VR</code> 技术上有很大的发展空间，而 <code>Live2d</code> 至今还没有找到合适的契合点，但是这丝毫不影响宅男对这项技术的热爱。</p>
<p><a href="https://dp2px.com/post/hexo-live2d/image1.webp"><img src="https://dp2px.com/post/hexo-live2d/image1.webp" alt="Live2d 二维模型演示"></a>Live2d 二维模型演示</p>……]]></summary>
            
                <content type="html"><![CDATA[<h2 id="live2d-是什么">Live2d 是什么</h2>
<p>Live2d 的官网地址：https://www.live2d.com/zh-CHS/</p>
<p>Live2d 是一种 <code>2d</code> 的绘图渲染技术，是由日本的一个叫 <code>Cybernoids</code> 的公司开发，通过一系列可以连续动画的的人物或者动物来建立模型，生成一种可以动的 <code>2d</code> 图形或者说二维模型。这种模型和二次元很接近，所以喜欢这种风格的人很多，但是也有它自身的缺陷那就是不容易商业化和更快的发展，例如现在的 <code>3d</code> 模型在游戏上和 <code>VR</code> 技术上有很大的发展空间，而 <code>Live2d</code> 至今还没有找到合适的契合点，但是这丝毫不影响宅男对这项技术的热爱。</p>
<p><a href="https://dp2px.com/post/hexo-live2d/image1.webp"><img src="https://dp2px.com/post/hexo-live2d/image1.webp" alt="Live2d 二维模型演示"></a>Live2d 二维模型演示</p>
<h2 id="live2d-的制作过程">Live2d 的制作过程</h2>
<p>官网下载安装包直接安装可以得到两种软件，分别是 <code>Cubism Modeler</code> 和 <code>Cubism Animator</code>，最后我们还需要安装第三个软件 <code>Viewer</code> 用作预览调戏等。</p>
<p>由于还是由 <code>2d</code> 图形制作，所以对动画师要求比较高，除去原画绘制能力，动画师还需要具有一定三维空间感，以及复杂逻辑能力。制作过程大致如下：</p>
<ul>
<li>使用 <code>PhotoShop</code> 制作 <code>psd</code> 格式的原画切图。</li>
<li>导入 <code>Cubism Modeler</code> 里蒙皮。</li>
<li>设置蒙皮。</li>
<li>导出到 <code>Cubism Animator</code> 里面开始制作动画。</li>
<li>最后再导出文件就完成了。</li>
</ul>
<h2 id="引入看板娘博客挂件">引入看板娘博客挂件</h2>
<h3 id="第一步依赖-dependencies">第一步：依赖 Dependencies</h3>
<p>你要确保你的页面中可以使用 <code>font-awesome</code>, 需要使用到，还有就是 <code>jQuery</code> 是否有添加。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&#34;</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&#34;</span><span class="p"></span><span class="p">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>如果你发现没有显示出来，检查一下你的 <code>jQuery</code> 是否正常引入了。</p>
<h3 id="第二步使用-usage">第二步：使用 Usage</h3>
<p>你可以使用一行代码完成看板娘的引入，你只需要在你的 <code>footer</code> 中添加如下代码即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js&#34;</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>做完这两步你已经完成了，但是我们这样做还是不够的，例如我们想修改看板娘上面的提示文字和锚点，和自己的网站内容关联和呼应，这样就需要将下面这几个文件下载到本地静态文件夹即可。</p>
<p><a href="https://dp2px.com/post/hexo-live2d/image2.png"><img src="https://dp2px.com/post/hexo-live2d/image2.png" alt="Live2d 本地需要下载的文件"></a>Live2d 本地需要下载的文件</p>
<p>这些文件你可以在原作者的 <code>GitHub</code> 上面下载，下载地址：https://github.com/stevenjoezhang/live2d-widget</p>
<p>接下来你只需要配置一下 <code>autoload.js</code> 里面的根目录即可，配置如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">//注意：live2d_path 参数应使用绝对路径
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">live2d_path</span> <span class="o">=</span> <span class="s2">&#34;/live2d/&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="自定义-live2d-看板娘">自定义 Live2d 看板娘</h2>
<p>安装完成后我们可以对看板娘的样式和头顶的气泡消息自定义，这样可以做出和自己网站很契合的交互效果，使这个看板娘成为你网站上独一无二的。</p>
<h3 id="live2d-看板娘大小调整">Live2d 看板娘大小调整</h3>
<p>调整看板娘的大小和上面气泡对话框的大小，还有侧边菜单的样式，是否显示等都可以在 <code>waifu.css</code> 样式文件中进行修改，我们只需要在浏览器中 F12 查看对应控件的名称即可，在样式文件中找到对应的元素标签进行修改即可。</p>
<p>当然，你也可以在浏览器中修改样式，这样可以一边修改一边查看效果，将有效果的修改结果更改到 <code>waifu.css</code> 文件中即可。</p>
<h3 id="live2d-自定义隐藏功能">Live2d 自定义隐藏功能</h3>
<p>我们如果想要隐藏组件中的某些地方，或者修改跳转链接，或者自定义显示按钮图标的样子都可以通过修改 <code>waifu-tips.js</code> 文件实现，例如我们要更改菜单的多少，可以这样修改：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">$</span><span class="p">(</span><span class="s2">&#34;body&#34;</span><span class="p">)</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="sb">`</span><span class="sb">&lt;div id=&#34;waifu&#34;&gt;
</span><span class="sb">    &lt;div id=&#34;waifu-tips&#34;&gt;&lt;/div&gt;
</span><span class="sb">    &lt;canvas id=&#34;live2d&#34; width=&#34;300&#34; height=&#34;300&#34;&gt;&lt;/canvas&gt;
</span><span class="sb">    &lt;div id=&#34;waifu-tool&#34;&gt;
</span><span class="sb">        &lt;span class=&#34;fa fa-lg fa-paper-plane&#34;&gt;&lt;/span&gt;
</span><span class="sb">        &lt;span class=&#34;fa fa-lg fa-user-circle&#34;&gt;&lt;/span&gt;
</span><span class="sb">        &lt;span class=&#34;fa fa-lg fa-street-view&#34;&gt;&lt;/span&gt;
</span><span class="sb">        &lt;span class=&#34;fa fa-lg fa-camera-retro&#34;&gt;&lt;/span&gt;
</span><span class="sb">        &lt;span class=&#34;fa fa-lg fa-times&#34;&gt;&lt;/span&gt;
</span><span class="sb">    &lt;/div&gt;
</span><span class="sb">&lt;/div&gt;</span><span class="sb">`</span><span class="p">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>只需要修改这里的标签，不需要的删除即可，如果要添加就追加一个，其他地方也是类似的设置，如果需要你可以查看该文件修改其他地方。</p>
<h3 id="live2d-看板娘对话自定义">Live2d 看板娘对话自定义</h3>
<p>我们的看板娘会时不时的和我们对话，而且你会发现当你的鼠标从某个标签或者链接上面移动过后，看板娘都会和你互动，而这个互动可能和我们的网站内容不契合，所以我们需要打开文件 <code>waifu-tips.json</code> 来进行修改，或者进行删除，当然也可以添加新的。</p>
<p>这个文件里面的内容大致结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;mouseover&#34;</span><span class="p">:</span> <span class="p">[</span><span class="p">{</span>
        <span class="nt">&#34;selector&#34;</span><span class="p">:</span> <span class="s2">&#34;#waifu #live2d&#34;</span><span class="p">,</span>
        <span class="nt">&#34;text&#34;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&#34;对话提示一&#34;</span><span class="p">,</span> <span class="s2">&#34;对话提示二&#34;</span><span class="p">]</span>
    <span class="p">}</span><span class="p">]</span><span class="p">,</span>
    <span class="nt">&#34;click&#34;</span><span class="p">:</span> <span class="p">[</span><span class="p">{</span>
        <span class="nt">&#34;selector&#34;</span><span class="p">:</span> <span class="s2">&#34;#waifu #live2d&#34;</span><span class="p">,</span>
        <span class="nt">&#34;text&#34;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&#34;对话提示一&#34;</span><span class="p">,</span> <span class="s2">&#34;对话提示二&#34;</span><span class="p">]</span>
    <span class="p">}</span><span class="p">]</span><span class="p">,</span>
    <span class="nt">&#34;seasons&#34;</span><span class="p">:</span> <span class="p">[</span><span class="p">{</span>
        <span class="nt">&#34;date&#34;</span><span class="p">:</span> <span class="s2">&#34;01/01&#34;</span><span class="p">,</span>
        <span class="nt">&#34;text&#34;</span><span class="p">:</span> <span class="s2">&#34;对话提示&#34;</span>
    <span class="p">}</span><span class="p">]</span>   
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p>从上面的 json 结构中可以看出来，实际上对我们的事件响应做出三个分类，一种使鼠标移动事件，另一种使鼠标点击事件，还有一种使日期事件，我们可以给这些集合中添加我们想绑定的事件，<code>selector</code> 就是要绑定事件的标签的id, 而 <code>text</code> 则是绑定后提示的文本，如果有多条则会随机提示其中的某一条。</p>
<p>做到这里已经能基本满足我们的需求，如果你还想深度定制也可以，你可以研究一下源代码，然后定制更好玩的东西出来。关于博客装扮和美化还有很多好玩的东西，如果你有兴趣可以看看我写的关于博客美化的这篇文章 <a href="https://dp2px.com/2019/04/25/hexo-meihua/">《Hexo主题（Next）美化、配置、优化这一篇就够了》</a></p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/%E5%8D%9A%E5%AE%A2/" term="博客" label="博客" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/live2d/" term="live2d" label="live2d" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Jsoup爬虫入门</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/jsoup%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8-%E5%89%AF%E6%9C%AC/" />
            <id>https://example.com/posts/jsoup%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8-%E5%89%AF%E6%9C%AC/</id>
            <updated>2020-04-13T15:44:35+08:00</updated>
            <published>2019-02-14T16:01:23+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<p>jsoup是一款Java的HTML解析器，主要用来对HTML解析。</p>
<h2 id="一导入依赖">一.导入依赖</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="o">&lt;</span><span class="n">dependency</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">groupId</span><span class="o">&gt;</span><span class="n">org</span><span class="o">.</span><span class="na">jsoup</span><span class="o">&lt;</span><span class="o">/</span><span class="n">groupId</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">artifactId</span><span class="o">&gt;</span><span class="n">jsoup</span><span class="o">&lt;</span><span class="o">/</span><span class="n">artifactId</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span><span class="n">1</span><span class="o">.</span><span class="na">10</span><span class="o">.</span><span class="na">2</span><span class="o">&lt;</span><span class="o">/</span><span class="n">version</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="o">/</span><span class="n">dependency</span><span class="o">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="二爬取数据">二.爬取数据</h2>
<p>新建一个HtmlParseUtil工具类</p>……]]></summary>
            
                <content type="html"><![CDATA[<p>jsoup是一款Java的HTML解析器，主要用来对HTML解析。</p>
<h2 id="一导入依赖">一.导入依赖</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="o">&lt;</span><span class="n">dependency</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">groupId</span><span class="o">&gt;</span><span class="n">org</span><span class="o">.</span><span class="na">jsoup</span><span class="o">&lt;</span><span class="o">/</span><span class="n">groupId</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">artifactId</span><span class="o">&gt;</span><span class="n">jsoup</span><span class="o">&lt;</span><span class="o">/</span><span class="n">artifactId</span><span class="o">&gt;</span>
 <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span><span class="n">1</span><span class="o">.</span><span class="na">10</span><span class="o">.</span><span class="na">2</span><span class="o">&lt;</span><span class="o">/</span><span class="n">version</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="o">/</span><span class="n">dependency</span><span class="o">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="二爬取数据">二.爬取数据</h2>
<p>新建一个HtmlParseUtil工具类</p>
<h3 id="1获取请求需要联网">1.获取请求（需要联网）</h3>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200412235228.png" alt=""></p>
<p>2.用Jsoup将HTML转化为Doucument对象</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">        <span class="n">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">&#34;https://search.jd.com/Search?keyword=keyword&#34;</span><span class="o">;</span>
        <span class="n">Document</span> <span class="n">document</span> <span class="o">=</span> <span class="n">Jsoup</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="k">new</span> <span class="n">URL</span><span class="o">(</span><span class="n">url</span><span class="o">)</span><span class="o">,</span> <span class="n">20000</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3获取需要的节点属性">3.获取需要的节点属性</h3>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200412235258.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Element</span> <span class="n">element</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="na">getElementById</span><span class="o">(</span><span class="s">&#34;J_goodsList&#34;</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>输出看是否成功获取</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">element</span><span class="o">.</span><span class="na">html</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200412235357.png" alt=""></p>
<p>成功获取到该节点属性，分析一下html,发现自己所需要爬取的内容都在该节点的li元素中</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200412235418.png" alt=""></p>
<p>获取所有的li元素，并获取元素中的内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Elements</span> <span class="n">elements</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getElementsByTag</span><span class="o">(</span><span class="s">&#34;li&#34;</span><span class="o">)</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="n">Element</span> <span class="n">element1</span> <span class="o">:</span> <span class="n">elements</span><span class="o">)</span> <span class="o">{</span>
     <span class="c1">//图片特别多的网站，懒加载,图片路径一般不放在src里，分析html发现放在source-data-lazy-img下
</span><span class="c1"></span>     <span class="n">String</span> <span class="n">img</span> <span class="o">=</span> <span class="n">element1</span><span class="o">.</span><span class="na">getElementsByTag</span><span class="o">(</span><span class="s">&#34;img&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="n">0</span><span class="o">)</span><span class="o">.</span><span class="na">attr</span><span class="o">(</span><span class="s">&#34;source-data-lazy-img&#34;</span><span class="o">)</span><span class="o">;</span>
     <span class="n">String</span> <span class="n">price</span><span class="o">=</span> <span class="n">element1</span><span class="o">.</span><span class="na">getElementsByClass</span><span class="o">(</span><span class="s">&#34;p-price&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="n">0</span><span class="o">)</span><span class="o">.</span><span class="na">text</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
     <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">element1</span><span class="o">.</span><span class="na">getElementsByClass</span><span class="o">(</span><span class="s">&#34;p-name&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="n">0</span><span class="o">)</span><span class="o">.</span><span class="na">text</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;==========================&#34;</span><span class="o">)</span><span class="o">;</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">img</span><span class="o">)</span><span class="o">;</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">)</span><span class="o">;</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">price</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200412235452.png" alt=""></p>
<p>成功爬取到想要获取的信息</p>
<p>项目代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HtmlParseUtil</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">{</span>        
        <span class="n">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">&#34;https://search.jd.com/Search?keyword=keyword&#34;</span><span class="o">;</span>
        <span class="n">Document</span> <span class="n">document</span> <span class="o">=</span> <span class="n">Jsoup</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="k">new</span> <span class="n">URL</span><span class="o">(</span><span class="n">url</span><span class="o">)</span><span class="o">,</span> <span class="n">20000</span><span class="o">)</span><span class="o">;</span>
        <span class="n">Element</span> <span class="n">element</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="na">getElementById</span><span class="o">(</span><span class="s">&#34;J_goodsList&#34;</span><span class="o">)</span><span class="o">;</span>
<span class="c1">//      System.out.println(element.html());
</span><span class="c1"></span>        <span class="n">Elements</span> <span class="n">elements</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getElementsByTag</span><span class="o">(</span><span class="s">&#34;li&#34;</span><span class="o">)</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Element</span> <span class="n">element1</span> <span class="o">:</span> <span class="n">elements</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">img</span> <span class="o">=</span> <span class="n">element1</span><span class="o">.</span><span class="na">getElementsByTag</span><span class="o">(</span><span class="s">&#34;img&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="n">0</span><span class="o">)</span><span class="o">.</span><span class="na">attr</span><span class="o">(</span><span class="s">&#34;source-data-lazy-img&#34;</span><span class="o">)</span><span class="o">;</span>
            <span class="n">String</span> <span class="n">price</span><span class="o">=</span> <span class="n">element1</span><span class="o">.</span><span class="na">getElementsByClass</span><span class="o">(</span><span class="s">&#34;p-price&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="n">0</span><span class="o">)</span><span class="o">.</span><span class="na">text</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">element1</span><span class="o">.</span><span class="na">getElementsByClass</span><span class="o">(</span><span class="s">&#34;p-name&#34;</span><span class="o">)</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="n">0</span><span class="o">)</span><span class="o">.</span><span class="na">text</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;==========================&#34;</span><span class="o">)</span><span class="o">;</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">img</span><span class="o">)</span><span class="o">;</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">)</span><span class="o">;</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">price</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/java/" term="java" label="java" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/%E7%88%AC%E8%99%AB/" term="爬虫" label="爬虫" />
                            
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/java/" term="java" label="java" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">MySQL常用命令</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" />
            <id>https://example.com/posts/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
            <updated>2020-04-29T10:21:39+08:00</updated>
            <published>2019-02-08T16:01:23+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<h3 id="1新建数据库">1.新建数据库</h3>
<pre><code>creat database &lt;数据库名&gt; ;
</code></pre><h3 id="2显示数据库">2.显示数据库</h3>
<pre><code>show databases;
</code></pre><h3 id="3连接数据库">3.连接数据库</h3>
<pre><code>use &lt;数据库名&gt;;
</code></pre><h3 id="4显示数据表">4.显示数据表</h3>
<pre><code>show tables;
</code></pre>……]]></summary>
            
                <content type="html"><![CDATA[<h3 id="1新建数据库">1.新建数据库</h3>
<pre><code>creat database &lt;数据库名&gt; ;
</code></pre><h3 id="2显示数据库">2.显示数据库</h3>
<pre><code>show databases;
</code></pre><h3 id="3连接数据库">3.连接数据库</h3>
<pre><code>use &lt;数据库名&gt;;
</code></pre><h3 id="4显示数据表">4.显示数据表</h3>
<pre><code>show tables;
</code></pre><h3 id="5新建数据表">5.新建数据表</h3>
<pre><code>creat table 表的名字

 ( 列名a 数据类型(数据长度)  约束, 

   列名b 数据类型(数据长度)  约束，

   列名c 数据类型(数据长度)  约束);
</code></pre><h3 id="6插入数据">6.插入数据</h3>
<pre><code>insert into 表的名字(列名a,列名b,列名c) VALUES(值1,值2,值3);
</code></pre><h3 id="常见约束">常见约束</h3>
<h5 id="主键primary-key">主键：PRIMARY KEY</h5>
<p>constraint 主键名 primary key (字段名)</p>
<p>复合主键：constraint 主键名 primary key <strong>(字段名，字段名)</strong></p>
<h5 id="默认值default">默认值：DEFAULT</h5>
<h5 id="唯一约束-unique">唯一约束 ：UNIQUE</h5>
<h5 id="外键约束foreign-key">外键约束:FOREIGN KEY</h5>
<p>constraint 主键名 foreign key (字段名) references 表名（表的主键）</p>
<h5 id="非空约束not-null">非空约束：NOT NULL</h5>
<h3 id="基本的select语句">基本的SELECT语句</h3>
<p>SELECT 要查询的列名 FROM 表名 WHERE 限制条件;</p>
<p><strong>排序</strong>：<strong>ORDER BY</strong> 的结果是<strong>升序</strong>排列，而使用关键词 <strong>ASC</strong> 和 <strong>DESC</strong> 可指定<strong>升序</strong>或<strong>降序</strong>排序</p>
<h4 id="sql-内置函数和计算">SQL 内置函数和计算：</h4>
<table>
<thead>
<tr>
<th>函数名：</th>
<th>COUNT</th>
<th>SUM</th>
<th>AVG</th>
<th>MAX</th>
<th>MIN</th>
</tr>
</thead>
<tbody>
<tr>
<td>作用：</td>
<td>计数</td>
<td>求和</td>
<td>求平均值</td>
<td>最大值</td>
<td>最小值</td>
</tr>
</tbody>
</table>
<h4 id="数据库及表的修改和删除"><strong>数据库及表的修改和删除</strong></h4>
<p><strong>删除数据库</strong></p>
<pre><code>DROP DATABASE 数据库名;
</code></pre><p><strong>重命名一张表</strong></p>
<pre><code>RENAME TABLE 原名 TO 新名字; 
或
ALTER TABLE 原名 RENAME 新名; 
或
ALTER TABLE 原名 RENAME TO 新名;
</code></pre><p><strong>删除一张表</strong></p>
<pre><code>DROP TABLE 表名字;
</code></pre><p><strong>增加一列</strong></p>
<pre><code>ALTER TABLE 表名字 ADD COLUMN 列名字 数据类型 约束;
或：
ALTER TABLE 表名字 ADD 列名字 数据类型 约束;
</code></pre><p>如果要把增加的列插入在指定位置，则需要在语句的最后使用AFTER关键词(<strong>“AFTER 列1” 表示新增的列被放置在 “列1” 的后面</strong>)。</p>
<p><strong>删除一列</strong></p>
<pre><code>ALTER TABLE 表名字 DROP COLUMN 列名字;
或： 
ALTER TABLE 表名字 DROP 列名字;
</code></pre><p><strong>重命名一列</strong></p>
<pre><code>ALTER TABLE 表名字 CHANGE 原列名 新列名 数据类型 约束;
</code></pre><p><strong>改变数据类型</strong></p>
<pre><code>ALTER TABLE 表名字 MODIFY 列名字 新数据类型;
</code></pre><p><strong>修改表中某个值</strong></p>
<pre><code>UPDATE 表名字 SET 列1=值1,列2=值2 WHERE 条件;
</code></pre><p><strong>删除一行记录</strong></p>
<pre><code>DELETE FROM 表名字 WHERE 条件;
</code></pre><h4 id="索引">索引</h4>
<p>新建索引</p>
<pre><code>ALTER TABLE 表名字 ADD INDEX 索引名 (列名);
或
CREATE INDEX 索引名 ON 表名字 (列名);
</code></pre><p>查看索引</p>
<pre><code>SHOW INDEX FROM 表名字
</code></pre><p>比如有一个用户表，它拥有用户名(username)和个人签名(note)两个字段。其中用户名具有唯一性，并且格式具有较强的限制，我们给用户名加上一个唯一索引；个性签名格式多变，而且允许不同用户使用重复的签名，不加任何索引。</p>
<p>一些字段不适合创建索引，比如性别，这个字段存在大量的重复记录无法享受索引带来的速度加成，甚至会拖累数据库，导致数据冗余和额外的 CPU 开销。</p>
<h4 id="视图">视图</h4>
<p>创建视图</p>
<pre><code>CREATE VIEW 视图名(列a,列b,列c) AS SELECT 列1,列2,列3 FROM 表名字;
</code></pre><p>视图是从一个或多个表中导出来的表，是一种<strong>虚拟存在的表</strong>。它就像一个窗口，通过这个窗口可以看到系统专门提供的数据，这样，用户可以不用看到整个数据库中的数据，而只关心对自己有用的数据。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/mysql/" term="mysql" label="mysql" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/mysql/" term="mysql" label="mysql" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">SpringBoot入门(一)：认识SpingBoot</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/springboot%E5%85%A5%E9%97%A8%E4%B8%80%E8%AE%A4%E8%AF%86spingboot/" />
            <id>https://example.com/posts/springboot%E5%85%A5%E9%97%A8%E4%B8%80%E8%AE%A4%E8%AF%86spingboot/</id>
            <updated>2020-04-15T13:15:24+08:00</updated>
            <published>2019-02-05T06:07:00+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<blockquote>
<p>Spring是一个开源框架，是 Spring 全家桶中的一员,2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson  。</p>
<p>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。</p>
</blockquote>
<h4 id="什么是-spring-boot">什么是 Spring Boot</h4>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200414164213.png" alt=""></p>……]]></summary>
            
                <content type="html"><![CDATA[<blockquote>
<p>Spring是一个开源框架，是 Spring 全家桶中的一员,2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson  。</p>
<p>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。</p>
</blockquote>
<h4 id="什么是-spring-boot">什么是 Spring Boot</h4>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/20200414164213.png" alt=""></p>
<p>Spring Boot 其实就是 Spring，学过 Spring 的大家一定都知道，即使是一个很简单的程序，Spring 都需要大量的配置。而 Spring Boot 将我们从配置文件中解放了出来，Spring Boot 提供了大量的默认配置，我们只需要少数的配置甚至不配置，就可以建立起来一个 Spring Boot 应用，简直就是 Java 程序员的福音。</p>
<p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以<strong>约定大于配置的核心思想</strong>，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p>
<p>简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。</p>
<p>Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。</p>
<h4 id="spring-boot-的优点">Spring Boot 的优点</h4>
<ul>
<li>为所有Spring开发者更快的入门</li>
<li>开箱即用，提供各种默认配置来简化项目配置</li>
<li>内嵌式容器简化Web项目</li>
<li>没有冗余代码生成和XML配置的要求。</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/springboot/" term="SpringBoot" label="SpringBoot" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/springboot/" term="SpringBoot" label="SpringBoot" />
                            
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/java/" term="java" label="java" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">PicGo &#43; Gitee(码云)实现markdown图床</title>
            <link rel="alternate" type="text/html" href="https://example.com/posts/picgo-&#43;-gitee%E5%AE%9E%E7%8E%B0markdown%E5%9B%BE%E5%BA%8A/" />
            <id>https://example.com/posts/picgo-&#43;-gitee%E5%AE%9E%E7%8E%B0markdown%E5%9B%BE%E5%BA%8A/</id>
            <updated>2020-04-15T10:14:58+08:00</updated>
            <published>2019-02-03T16:01:23+08:00</published>
            <author>
                    <name>小青蛙</name>
                    <uri>https://io-oi.me/</uri>
                    <email>1612291475@qq.com</email>
                    </author>
            <rights>[赣ICP备20004830号](http://www.beian.miit.gov.cn/)</rights>
    
    <summary type="html"><![CDATA[<p>咱们写博客的时候，总是需要插入图片的，图片存在本地的话上传到博客网站去就没法显示了，就算一个图一个图的复制粘贴上去，想移植到其他的博客网站，图就会失效，我们就需要图床</p>
<blockquote>
<p>图床是干什么的？
图床就是一个便于在博文中插入在线图片连接的个人图片仓库。设置图床之后，在自己博客中插入的图片链接就可以随时随地在线预览了，并且不会因为任何意外原因无法查看，除非自己亲自删除。</p>
</blockquote>
<p>神奇的PicGo就是为了解决这个问题诞生的，它可以将图片上传到指定的图床上，然后返回markdown链接，直接粘贴到你的文档中，就搞定啦</p>……]]></summary>
            
                <content type="html"><![CDATA[<p>咱们写博客的时候，总是需要插入图片的，图片存在本地的话上传到博客网站去就没法显示了，就算一个图一个图的复制粘贴上去，想移植到其他的博客网站，图就会失效，我们就需要图床</p>
<blockquote>
<p>图床是干什么的？
图床就是一个便于在博文中插入在线图片连接的个人图片仓库。设置图床之后，在自己博客中插入的图片链接就可以随时随地在线预览了，并且不会因为任何意外原因无法查看，除非自己亲自删除。</p>
</blockquote>
<p>神奇的PicGo就是为了解决这个问题诞生的，它可以将图片上传到指定的图床上，然后返回markdown链接，直接粘贴到你的文档中，就搞定啦</p>
<h2 id="1-安装">1. 安装</h2>
<ul>
<li>PicGo</li>
<li>gitee 1.2.2-beta插件</li>
</ul>
<h4 id="首先打开upicgo官网httpslinkzhihucomtargethttps3agithubcommolunerfinnpicgou下载安装包">首先打开<strong><u><a href="https://link.zhihu.com/?target=https%3A//github.com/Molunerfinn/PicGo">picgo官网</a></u></strong>，下载安装包</h4>
<p><img src="https://pic2.zhimg.com/80/v2-6a5d78ebb1910843ff4d2872580d21a5_720w.png" alt="img"></p>
<h3 id="安装之后打开主界面">安装之后打开主界面</h3>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/image-20200408153822640.png" alt=""></p>
<h3 id="选择最底下的插件设置搜索gitee">选择最底下的插件设置，搜索<strong>gitee</strong></h3>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/image-20200408154045567.png" alt="image-20200408154045567"></p>
<h3 id="点击左边的gitee-122-beta开始安装">点击左边的<strong>gitee 1.2.2-beta</strong>开始安装</h3>
<blockquote>
<p>这里注意一下，必须要先安装<a href="https://link.zhihu.com/?target=https%3A//nodejs.org/en/">node.js</a>才能安装插件，没装的自己装一下，然后重启就行。</p>
</blockquote>
<p>这个地方有两个插件，我试了一遍，两个都能用，大家看心情选择，先说一下左边这个<strong>gitee 1.2.2-beta</strong>，用不了的同学就选右边那个，大体基本相同</p>
<h2 id="2-建立gitee码云图床库">2. 建立gitee（码云）图床库</h2>
<p>注册码云的方法很简单，网站引导都是中文，不多说了，我们直接建立自己的图床库。</p>
<h3 id="点击右上角的号新建仓库">点击右上角的+号，新建仓库</h3>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/image-20200408154436124.png" alt=""></p>
<p>新建仓库的要点如下：</p>
<ol>
<li>输入一个仓库名称</li>
<li>其次将仓库设为公开</li>
<li>勾选使用Readme文件初始化这个仓库</li>
</ol>
<p><strong>这个选项勾上，这样码云会自动给你的仓库建立master分支，这点很重要!!!</strong> 我因为这点折腾了很久，因为使用github做图床picgo好像会自动帮你生成master分支，而picgo里的gitee插件不会帮你自动生成分支。</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/image-20200408154652152.png" alt="image-20200408154652152"></p>
<p>点击创建进入下一步</p>
<hr>
<h2 id="3-配置picgo">3. 配置PicGo</h2>
<p>安装了<strong>gitee 1.2.2-beta</strong>插件之后，我们开始配置插件</p>
<h3 id="配置插件的要点如下">配置插件的要点如下：</h3>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/LI.jpg" alt=""></p>
<ul>
<li>
<p>url：图床网站，这里写码云的主页 <a href="https://link.zhihu.com/?target=https%3A//gitee.com">https://gitee.com</a></p>
</li>
<li>
<p>owner：所有者，写上你的码云账号名，如果你不知道你的账号名，进入你刚才的仓库</p>
</li>
<li>
<p>repo：仓库名称，只要写上仓库名称就行，比如我自己的仓库blogImage</p>
</li>
<li>
<p>path：写上路径，一般是img，<strong>这几个项都不用加“ / “符号</strong></p>
</li>
<li>
<p>message：不用填</p>
</li>
</ul>
<h3 id="这个token怎么获取下面登录进自己的码云">这个token怎么获取，下面登录进自己的码云</h3>
<ol>
<li>
<p>点击头像，进入设置</p>
</li>
<li>
<p>找到右边安全设置里面的私人令牌</p>
</li>
</ol>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/image-20200409000147527.png" alt="image-20200409000147527"></p>
<ol>
<li>点击<code>生成新令牌</code>，把<strong>projects</strong>这一项勾上，其他的不用勾，然后提交</li>
</ol>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/image-20200409000126528.png" alt="image-20200409000126528"></p>
<p>这里需要验证一下密码，验证密码之后会出来一串数字，这一串数字就是你的token，将这串数字复制到刚才的配置里面去。</p>
<p><img src="https://gitee.com/zyh-h/blogimg/raw/master/img/image-20200408235506861.png" alt=""></p>
<blockquote>
<p>注意：这个令牌只会明文显示一次，建议在配置插件的时候再来生成令牌，直接复制进去，搞丢了又要重新生成一个。</p>
</blockquote>
<p>现在保存你刚才的配置，然后将它设置为默认图床，大功告成。</p>
<h4 id="还有一个插件picgo-plugin-gitee-uploader功能差不多刚才那个能用的话就不需要用这个配置的内容有点差别">还有一个插件picgo-plugin-gitee-uploader，功能差不多，刚才那个能用的话就不需要用这个，配置的内容有点差别</h4>
<hr>
<h2 id="4-测试">4. 测试</h2>
<p>随便选一张图片上传（picgo也支持剪贴板上传，截图工具推荐win10的<em>Snipaste</em>神器！），试试看超级快有木有！比github快很多，0.1秒上传，而且导入到你的markdown编辑器里面也是秒识别你的图片内容，而如果是github图床上传太慢不说可能还会出现识别不出来的问题！</p>
<p>上传之后默认复制链接，直接粘贴到你的markdown编辑器里，就可以愉快的进行写作了！</p>
<p>最后推荐一下我的博客写作套件<strong>Typora + PicGo + Snipaste</strong>，Typora写文档，Snipaste一键截图，PicGo一键上传图片返回链接。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/categories/%E5%8D%9A%E5%AE%A2/" term="博客" label="博客" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://example.com/tags/%E5%8D%9A%E5%AE%A2/" term="博客" label="博客" />
                            
                        
                    
                
            
        </entry>
    
</feed>
